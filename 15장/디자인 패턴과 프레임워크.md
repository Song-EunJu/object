## 15장 : 디자인 패턴과 프레임워크

- `디자인 패턴` : 소프트웨어 설계에서 반복적 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법
    - **설계를 재사용**하는 것이 목적!
    - 반복적으로 재사용할 수 있는 설계의 묶음
    - 특정한 변경을 일관성있게 다룰 수 있는 **협력템플릿**
- `프레임워크` : 애플리케이션의 아키텍처를 구현 코드의 형태로 제공함
    - **설계와 코드를 함께 재사용**하기 위한 것
    - 애플리케이션 요구에 따라 적절하게 커스터마이징할 수 있는 확장포인트 제공
    - 특정한 변경을 일관성있게 다룰 수 있는 **확장 가능한 코드 템플릿**
- 2가지 모두 협력을 일관성 있게 만들기 위한 방법

### 디자인 패턴과 설계 재사용

- 패턴은 실무 컨텍스트에서 탄생했고, 모델의 유용성이 널리 받아들여지는 경우에만 패턴으로 인정됨
- `패턴` : 한 컨텍스트에서 유용한 동시에, 다른 컨텍스트에서도 유용한 아이디어
    - 패턴으로 인정하기 위한 조건 (3의 규칙) : 3가지의 서로 다르 시스템에 특별한 문제 없이 적용할 수 있음
    - 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이 큰 가치임
    - 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기에, 패턴에서 가장 중요한 요소는 패턴의 이름
- 패턴의 범위는 소프트웨어 개발과 직접 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아님.
    - 다양한 프로젝트 조직 구성 방법, 프로젝트 일정 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항 관리하는 방법 같이 **반복적 규칙을 발견할 수 있는 모든 영역**이 패턴의 대상이 될 수 있음
- `패턴 언어` : 연관된 패턴들의 집합들이 모여 구성함
- 패턴 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄 (4가지) 로 분류됨
    - 디자인 패턴 : 특정 상황에서 일반적인 설계 문제 해결, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조 서술

### 패턴 분류

- `아키텍처 패턴` : 전체적인 구조를 결정하기 위해 사용할 수 있는 것으로, **구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공**하며 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적
- `디자인 패턴` : 특정 정황 내에서 일반적인 설계 문제를 해결하며, **협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술** / 특정한 설계 문제를 해결하는 것을 목적으로 하며 프로그래밍 언어나 프로그래밍 패러다임에 독립적
- `이디엄 패턴` : **특정 프로그래밍 언어에만 국한**된 하위 레벨 패턴으로, 주어진 언어의 기능을 이용해 컴포넌트 or 컴포넌트 간의 특정 측면을 구현하는 방법 서술
- `분석 패턴` : 도메인 내의 **개념적인 문제를 해결**하는 데 초점을 맞춘 것 / 업무 모델링 시에 발견되는 **공통적인 구조를 표현**하는 개념들의 집합

### 패턴과 책임-주도 설계

- 패턴 : 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿
- **STRATEGY 패턴** : 다양한 알고리즘을 동적으로 교체할 수 있는 역할, 책임의 집합 제공
    - Movie - DiscountPolicy 사이의 결합도를 낮게 유지할 수 있어, 런타임에 알고리즘 변경 가능
- **BRIDGE 패턴** : 추상화의 조합으로 인한 클래스의 폭발적 증가 문제를 해결하기 위해, 역할과 책임을 추상화와 구현의 2가지 집합으로 분해하여 설계를 확장 가능하게 함
- **OBSERVER 패턴** : 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합 제공
- 패턴을 따르게 되면, 특정 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다
- 패턴의 구성요소 : 클래스가 아니라 `역할`
    - 패턴 구성 요소가 클래스가 아니라 역할이라는 사실은, 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 뜻!
- **COMPOSITE 패턴** : 클라이언트가 개별객체와 복합객체를 동일하게 취급할 수 있는 패턴
    - Component, Leaf, Composite 는 클래스가 아니라 협력에 참여하는 객체들의 역할
    - 개별 객체와 복합 객체라는 **객체의 수와 관련된 변경을 캡슐화**하는 것이 목적
- 어떤 구현 코드가, 어떤 디자인 패턴을 따른다고 할 때는 역할/책임/협력 관점에서 유사 특성을 공유한다는 것이고 **특정 구현 방식을 강제하는 것이 아님!**

### 캡슐화와 디자인 패턴

- 디자인 패턴은 **협력을 일관성 있고 유연하게 만드는 것을 목적**으로 하며, **특정한 변경을 캡슐화하기 위한 독자적 방법을 정의하고 있음**
- **TEMPLATE METHOD 패턴** : 알고리즘을 캡슐화하기 위해 합성이 아닌 `상속` 관계를 사용하는 것
    - 상속을 사용할 경우 추상 메소드로 변경을 캡슐화 해야 함
    - 부모 클래스가 **알고리즘의 기본 구조를 정의**하고, **구체적 단계는 자식 클래스에서 정의**하게 함으로써 변경을 캡슐화할 수 있는 패턴
    - STRATEGY 패턴처럼 런타임에 알고리즘 변경은 불가, 하지만 알고리즘 교체와 같은 요구사항이 없는 경우 **복잡도를 낮출 수 있다**는 면에서 장점
- **DECORATOR 패턴** : 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로, 객체 행동을 결합하기 위해 합성 사용 (선택적 행동의 개수와 순서에 대한 변경 캡슐화 가능)
- 디자인 패턴에서는 구현 방법이나 구조가 아니고, **어떤 디자인 패턴이 어떤 변경을 캡슐화하는지! 변경을 캡슐화하기 위해 어떤 방법을 사용하는 지!** 이해하는 것이 중요함

### 패턴은 목적지가 아니라 출발지이다

- 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라
    - 패턴 만능주의 : 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것
- `**해결하려는 문제에 집중하는 것이 아니라**` 패턴이 제시하는 구조를 맹목적으로 따르다보면, 불필요하게 복잡하고 유지보수하기 어려운 시스템을 낳게 된다
    - **복잡성의 가치가 단순성을 넘어설 때만 패턴을 사용하라 !**
    - 패턴이 적용된 최종 결과를 이해하는 게 아니라, **소프트웨어 설계가 발전해 온 과정**을 공부하고, **패턴을 목표로 리팩토링하는 이유를 이해하는 것**이 훨씬 중요하다

### 코드 재사용 vs. 설계 재사용

- 디자인 패턴은 **프로그래밍 언어에 독립적으로** 재사용 가능한 설계 아이디어를 제공하는 것이 목적이다
    - 따라서 설계 아이디어를 프로그래밍 언어 특성에 맞춰 가공해야 하고, 매번 구현 코드를 재작성해야 한다는 단점이 있음
- 설계 재사용과 코드 재사용을 적절하게 조합하는 것이 가장 이상적인데, **설계를 재사용 하면서도 유사한 코드를 반복적으로 구현하지 않기 위한 방법**이 `프레임워크` 이다.
    - 코드를 재사용함으로써 설계 아이디어를 재사용함
- 프레임 워크의 핵심은 추상 클래스나 인터페이스와 같은 `추상화`
    - 가급적이면 의존성이 추상클래스/인터페이스와 같은 추상화를 향하도록 작성하자
- **변하는 것 (구체적인 세부사항)** 과 **변하지 않는 것 (상위 정책에 속하는 역할들의 협력 구조)** 을 분리하라
    - 변하는 것과 변하지 않는 것을 서로 다른 주기로 배포할 수 있게 별도의 `배포 단위` 로 분리해야 함
    - 처음에는 별도 패키지로 분리를 하고, **패키지 사이의 의존성 방향**을 추상화에만 의존하도록 조정해야 함 (세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 함)
- 상위 정책 구현하는 패키지가, 세부 사항 구현한 패키지로부터 완벽히 분리되면 상위 정책 패키지를 다른 애플리케이션에서 재사용 가능해짐
    - 즉, **재사용 가능한 XXX 로직을 구현한 프레임워크가 만들어진 것**
    - 프레임 워크는 여러 애플리케이션에 걸쳐 일관성 있는 협력 구현하게 해줌 → 동일 프레임워크 사용 시 구현 방식에 일관성이 있으므로 이해하기 쉬움

### 제어 역전의 원리

- 의존성 역전의 원리는 전통 설계 방법과, 객체지향을 구분하는 핵심적인 원리
- 의존성이 역전되어 있지 않다면, 절차적 설계를 갖는 것이다
- 의존성 역전 == `의존성의 방향` 역전 + `제어 흐름의 주체` 역전
    - 전통 구조 : 상위 정책 코드(애플리케이션 코드) 가, 하위의 구체적인 코드(재사용 가능한 라이브러리나 툴킷) 호출
    - 객체지향 구조 : **하위 정책 코드 (프레임워크) 가 상위 정책 코드 (애플리케이션 코드에 속하는 서브 클래스의 메소드) 호출**
    - **개별 애플리케이션에서, 프레임워크로 제어 흐름의 주체가 이동됨**
- 프레임워크에서는 일반적인 해결책만 제공, 애플리케이션에 따라 달라질 수 있는 특정 동작은 비워둠 → 남겨진 동작을 `훅` 이라고 부름
    - 훅 구현 방식은 애플리케이션 컨텍스트에 따라 달라짐
    - 재정의된 훅은 **제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출됨**
- 과거에는 우리가 직접 라이브러리 코드를 호출 했지만, 지금은 프레임워크가 호출하는 코드를 우리가 작성만 하게 된 것
    - 프레임워크가 제공하는 `메인 프로그램을 재사용`하고, 이 메인 프로그램이 호출하는 코드를 애플리케이션 개발자가 작성하는 것
    - 따라서 언제 자
