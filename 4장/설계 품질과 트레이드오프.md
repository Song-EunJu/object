## 4장 :  설계 품질과 트레이드오프

- 책임이 객체지향 어플리케이션 전체의 품질을 결정
    - 적절한 책임이 모여 협력이 되며, 역할은 책임의 집합이기 때문
- 데이터 중심 관점 == 객체의 `상태`에 초점 / 상태를 변경하는데 필요한 오퍼레이션을 정의
    - 상태는 구현의 일부, 상태는 구현의 일부이기에 상태 변경은 인터페이스의 변경 초래
- 책임 중심 관점 == 객체의 `행동` 에 초점 / 오퍼레이션을 위해 필요한 상태를 정의
    - 책임은 인터페이스의 일부, 인터페이스 뒤로 필요한 상태값 캡슐화
- Movie 클래스 처럼 객체의 종류를 저장하는 인스턴스 변수와, 인스턴스 종류에 따라 배타적으로 사용될 인스턴스 변수들이 하나의 클래스에 있다면
데이터 중심의 설계일 가능성이 높음

```java
public class Movie {
	private MovieType movieType;
	private Money discountAmount;
	private double discountPercent;
}
```

### 설계 트레이드오프

- 좋은 설계의 특징을 판단할 수 있는 기준
1. 캡슐화
    - 변경 가능성이 높은 부분 **(구현) 을 내부로 숨기고**, 외부에는 상대적으로 **안정적인 부분 (인터페이스) 만 공개**하여, 인터페이스만 의존할 수 있도록 조절하는 것
    - 외부에서 알 필요없는 부분을 감추어 **대상을 단순화하는 추상화의 한 종류**
2. 응집도
    - 모듈에 포함된 내부 요소들이 연관된 정도.
    - 객체 또는 클래스에 얼마나 `관련 높은 책임들을 할당했는지`
    - 응집도가 높다 vs. 응집도가 낮다
        - 하나의 변경을 위해, ***모듈 전체가 변경***되는 경우 vs. 모듈의 일부만 변경되는 경우
        - 하나의 변경을 위해, ***하나의 모듈이 변경***되는 경우 vs. 다수의 모듈이 변경되는 경우 (모듈 내의 요소들이 서로 다른 목적을 추구한 것)
    - 응집도가 높을수록, **변경 대상+범위가 명확해지므로** 변경에 용이
3. 결합도
    - 다른 모듈에 대해 `얼마나 많은 지식을 갖고 있는지`를 나타내는 척도
    - 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도
    - 결합도가 높다 vs. 결합도가 낮다
        - 내부 구현 변경 시 다른 모듈에 영향을 미치는 경우 vs. **퍼블릭 인터페이스 수정 시 다른 모듈에 영향** 미치는 경우
- 좋은 설계는 변경에 용이, 좋은 설계를 위해서는 높은 응집도 + 낮은 결합도 → 따라서, **높은 응집도 + 낮은 결합도를 추구하는 것은 변경에 용이하기 위함**
- 캡슐화를 지키면, 응집도 높아지고 결합도는 낮아진다
    - 캡슐화를 지키면, 변경 가능성 (구현) 은 내부로 숨기고, 외부에서는 인터페이스만 의존하게 한다
    - 따라서 퍼블릭 인터페이스를 수정할 때만 다른 모듈의 변경을 요구하므로 결합도가 낮다
    - 상태와 행동을 하나의 객체로 모아, 내부 구현을 외부로부터 감추기 때문에 응집도가 높다

### 데이터 중심 설계 시스템의 문제점

- 데이터 중심 설계 : 내부 구현을 인터페이스의 일부로 만들어서 캡슐화를 위반함
- 책임 중심 설계 : 내부구현을 인터페이스 뒤로 캡슐화

- **캡슐화 위반**
    - Movie 클래스에는 캡슐화를 구현하기 위해 추가했던 getFee, setFee 메소드 (접근자, 수정자) 를 통해 더더욱 캡슐화를 위반하게 됨
        - fee라는 변수가 존재함을 퍼블릭 인터페이스에 노골적으로 드러냄
        - 협력을 고려하지 않고, `객체가 다양한 상황에서 사용될 수 있을 거라는` 추측에 의한 설계전략을 따라 **과도하게 접근자, 수정자에 의존하게 되면**
        내부구현이 퍼블릭 인터페이스에 그대로 노출되어 캡슐화를 위반하게 됨
- **높은 결합도**
    - 캡슐화를 약화시켜, 객체의 내부구현이 인터페이스에 드러나므로 클라이언트가 구현에 강하게 결합됨
    - 따라서 인터페이스에 의존하는 모든 클라이언트에도 변경 발생
- **낮은 응집도**
    - `서로 다른 이유로 변경되는 코드가, 하나의 모듈 안에 공존할 때` 낮은 응집도를 가진다고 말함
    - **코드 수정 후 상관도 없는 코드에 문제가 발생하는 것이 낮은 응집도의 증거**
    - 로버트마틴의 `단일 책임 원칙, SRP` 는 모듈의 응집도가 변경과 연관있다는 사실을 강조하기 위해 제시된 설계 원칙
        - 단일 책임 원칙 == 클래스는 **단 한가지의 변경이유만 가져야 함**
        - 여기서 책임은, `변경의 이유` 라는 의미로 사용됨. 하나의 책임을 가져야 한다는 것이 아님 !!

### 자율적인 객체
- 캡슐화는 설계의 제 1원리
- 속성이 private 이더라도 접근자/수정자를 통해 **속성을 외부로 제공한다면** 캡슐화를 위반하는 것
    - 접근자/수정자는 **내부 구현을 인터페이스의 일부로 만들기 때문!**
- 상태+행동을 하나의 단위로 묶는 이유는 `객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서`

## 추가적인 질문이나 의문점

- `추상화` : 복잡한 시스템이나 데이터를 단순화하여, 이해하기 쉽게 만드는 것
- 캡슐화가 대상을 단순화하는 추상화의 한 종류면, 다른 방법에는 무엇이 있을까?
    - 상속
        - 클래스 간의 계층구조를 형성함으로써, 복잡한 시스템을 단순화 + 구조화 가능
    - 인터페이스
    - 추상클래스
        - 클래스 간의 공통행동을 추상화할 수 있음
