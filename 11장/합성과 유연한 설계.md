## 11장 : 합성과 유연한 설계

- 상속 : 부모, 자식 클래스를 연결해서 **부모 클래스의 코드 재사용**
    - 두 클래스 사이의 의존성은, `컴파일타임` 에 해결됨
    - 부모 클래스 내부 구현에 대해 상세히 알아야 함 (결합도 상승) → 화이트 박스 재사용
- 합성 : 전체를 표현하는 객체가, 부분을 표현하는 객체를 포함해서 **부분 객체 코드를 재사용 (=포함되는 객체의 퍼블릭 인터페이스를 재사용)**
    - 두 객체 사이의 의존성은, `런타임` 에 해결됨
    - 내부에 포함되는 객체의 구현이 아닌 **퍼블릭 인터페이스에 의존** (낮은 결합도) → 블랙박스 재사용

### 상속을 합성으로 변경하기
- **자식 클래스에 선언된 상속 관계 제거 후, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 됨**
- **불필요한 인터페이스 상속 문제)**
    - AS-IS : Stack / Properties 의 경우에는, 불필요하게 인터페이스를 상속하면서 자식 클래스 내부 구조에 대한 규칙을 무너뜨릴 여지가 있는 코드를 만들어냈음
    - TO-BE : 부모 클래스를 합성으로 변경하여 해당 인스턴스 변수를 통해, 부모 클래스의 퍼블릭 인터페이스를 통해서만 협력하게 되어, Stack / Properties 를 잘못 사용할 가능성을 깔끔하게 제거함
- **메소드 오버라이딩의 오작용 문제)**
    - HashSet 의 내부에 저장된 요소의 수를 셀 수 있는 기능을 추가한 InstrumentedHashSet 클래스 (HashSet 과 구현에 강하게 결합됨)
    - AS-IS : 자식 클래스가 부모 클래스의 메소드를 오버라이딩할 경우, 부모 클래스에 자식 클래스가 결합되어 예상치 못한 결과를 얻을 수 있음
    - TO-BE : InstrumentedHashSet 이 제공해야 하는 **모든 오퍼레이션을 가진 Set 인터페이스를 실체화하는 HashSet 인스턴스를 합성** <br>
    → HashSet 에 대한 구현 결합도는 제거하면서 **퍼블릭 인터페이스는 그대로 유지 가능**
        <br>
        ```java
        public class InstrumentedHashSet<E> implements Set<E> {
            private int addCount = 0;
            private Set<E> set;
        
            public InstrumentedHashSet(Set<E> set) {
                this.set = set;
            }
        
            @Override
            public boolean add(E e) {
                addCount++;
                return set.add(e);
            }
        
            @Override
            public boolean addAll(Collection<? extends E> c) {
                addCount += c.size();
                return set.addAll(c);
            }
        
            public int getAddCount() {
                return addCount;
            }
        
            @Override public boolean remove(Object o) {return set.remove(o);}
            @Override public void clear() {set.clear();} ...
        }
        ```
        
        - `포워딩` : 기존 클래스 (Set) 의 인터페이스를 그대로 외부에 제공하면서, 구현 (HashSet) 에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우 사용
        - `포워딩 메소드` : 동일한 메소드를 호출하기 위해 추가된 메소드 ex) remove, clear …
- **부모 클래스와 자식 클래스의 동시 수정 문제)**
    - 이 문제는 여전히 해결되지 않음

### 상속으로 인한 조합의 폭발적인 증가

- 상속 → 결합도 상승 → 코드 수정 시 필요한 작업량이 과도하게 늘어남
