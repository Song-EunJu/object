## 부록 A : 계약에 의한 설계

- 명령과 쿼리를 분리했더라도, 명령으로 인해 발생하는 **부수효과를 명확하게 표현하는 것은 한계가 있음**
    - 구현이 복잡하고 부수효과를 가진 다수의 메서드들을 연이어 호출하게 될 경우, 실행 결과를 예측하기 어려워짐
    - 인터페이스만으로는, **객체의 행동에 관한 다양한 관점을 전달하기가 어려움** <br>
    → 명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단인 `계약에 의한 설계` 가 필요
    
- 계약의 설계를 사용할 경우
    - 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화 가능
    - 계약은 실행 가능하기에, 구현에 동기화되어 있는지 여부를 런타임에 검증 가능

### 협력과 계약

- 인터페이스는 객체가 수신가능한 메시지는 정의할 수 있지만, 객체 사이의 의사소통 방식은 명확하게 정의 불가능
    - 협력을 위해 필요한 약속과 제약은 **인터페이스로 전달할 수 없어서, 협력과 관련된 상당한 내용은 암시적인 상태로 남음**
- Code Contracts 사용 예시
    - IsSatisfied 메서드 실행 결과가 true 일 때만 Reschedule 메서드를 호출할 수 있다는 사실을 명확하게 표현 가능

```java
public void Reschedule(RecurringSchedule schedule) {
	Contract.Requires(IsSatisfied(schedule));
}
```

- 정합성 체크로직은 코드 구현 내부에 숨겨져 있어, 코드를 분석하기 전에는 파악하기 쉽지 않은데 이러한 라이브러리/언어를 사용하면 일반 로직과 구분하여 **제약 조건을 명시적으로 표현하는 것이 가능해짐**
- 문서화로 끝나는 게 아니라, 제약 조건의 만족 여부를 실행중에도 체크 가능
- 이 조건들을 코드로부터 추출해서 문서를 만들어주는 자동화 도구도 제공
