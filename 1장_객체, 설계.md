## **1장 : 객체, 설계**

- 인스턴스 생성 시점에 인스턴스에 **`제약을 강제할 수 있는`** 생성자를 활용하자
    
    ex) 현금과 초대장을 함께 보관하는 경우, 초대장 없이 현금만 보관하는 경우 
    
- 지나치게 **`세부적인 사항에 의존하여 동작하지 않도록`** 짜자
    
    ex) 관람객이 가방을 들고 있어야 한다. 판매원이 매표소에서만 티켓을 판매한다
    
    → 의존성 (변경에 대한 영향을 암시하는 것) 과 관련된 문제
    
    - 객체 사이의 의존성이 과한 경우 : 결합도가 높다 == 함께 변경될 확률도 높다 == 변경하기 어려워진다
  
<br>

- **객체의 자율성을 높이자**
    - 캡슐화 : 객체 내부의 세부적인 사항을 감추는 것
        - **객체 내부로의 접근을 제한하면**, 객체-객체 간의 결합도를 낮출 수 있다
        
        → 즉, 변경하기 쉬운 객체를 만드는 것이 목적
        
    - 내부 구현을 외부에 노출하지 않고 **자신의 문제를 스스로 책임지고 해결하게 하자**
    - 객체 내부 상태를 캡슐화하고, 객체 간에 오직 **메시지를 통해서만 상호작용**하게 하자
    - 응집도가 높다 == 밀접하게 연관된 작업만 수행, 연관성 없는 작업은 다른 객체에게 위임 == 자신의 데이터를 스스로 처리


# 이 장에서 얻은 것


- A 객체에서 B 객체에 접근하는 코드를 B 객체 내부로 옮겨서 캡슐화하자
    
    [ AS-IS ] 
    
    ```java
    class TicketSeller {
    	public void sellTo(Audience audience){
    		if(audience.getBag().hasInvitation()){...}
    	}
    }
    ```
    
    ```java
    class Audience {
    	private Bag bag;
    	...
    }
    ```

    [ TO-BE ]

    ```java
    class TicketSeller { 
        public void sellTo(Audience audience){
            if(audience.buy(ticketOffice.getTicket())) ...
    }
    ```

    ```java
    class Audience {
            private Bag bag;
            public Long buy(Ticket ticket){
                if(bag.hasInvitation()){...}
            }
    }
    ```
<br>

- 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다