## **1장 : 객체, 설계**

- 인스턴스 생성 시점에 인스턴스에 **`제약을 강제할 수 있는`** 생성자를 활용하자
    
    ex) 현금과 초대장을 함께 보관하는 경우, 초대장 없이 현금만 보관하는 경우 
    
- 지나치게 **`세부적인 사항에 의존하여 동작하지 않도록`** 짜자
    
    ex) 관람객이 가방을 들고 있어야 한다. 판매원이 매표소에서만 티켓을 판매한다
    
    → 의존성 (변경에 대한 영향을 암시하는 것) 과 관련된 문제
    
    - 객체 사이의 의존성이 과한 경우 : 결합도가 높다 == 함께 변경될 확률도 높다 == 변경하기 어려워진다
<br>

- **객체의 자율성을 높이자**
    - 캡슐화 : 객체 내부의 세부적인 사항을 감추는 것
        - **객체 내부로의 접근을 제한하면**, 객체-객체 간의 결합도를 낮출 수 있다
        
        → 즉, 변경하기 쉬운 객체를 만드는 것이 목적
        
    - 내부 구현을 외부에 노출하지 않고 **자신의 문제를 스스로 책임지고 해결하게 하자**
    - 객체 내부 상태를 캡슐화하고, 객체 간에 오직 **메시지를 통해서만 상호작용**하게 하자
    - 응집도가 높다 == 밀접하게 연관된 작업만 수행, 연관성 없는 작업은 다른 객체에게 위임 == 자신의 데이터를 스스로 처리
<br>

- **절차지향과 객체 지향**
    - 절차지향 : 프로세스와 데이터를 `별도 모듈에 위치`시키는 것 / 결국 다른 클래스에 존재하고 있음
        - Theater 의 enter() : 프로세스
        - Audience, TicketSeller, Bag : 데이터 (수동적인 존재)
            
            → 모든 처리가 하나의 클래스 안에 위치하며, **나머지 클래스는 단지 데이터의 역할**만 수행
            
        - 프로세스가, 필요한 모든 데이터에 의존해야 하므로, 변경에 취약
    - 객체지향 : 데이터와 프로세스가 `동일 모듈 내부에 위치`
        - **자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 이동시키자**
            
            ex) bag.hasInvitation() 을 Audience 클래스의 buy 함수로 이동시킨다거나.. 
            
        
        → 캡슐화를 이용해, 의존성을 적절히 관리하여, 결합도를 낮춘다
<br>
    
- **적절한 객체에, 적절한 책임을 할당하자!**
    - 객체가 어떤 데이터를 가지느냐 <<<<<<<<<<<<<< 객체에 어떤 책임을 할당할 것이냐
    - 불필요한 의존성 제거 → 객체 사이의 결합도 ↓
        - 결합도를 낮추기 위해, 책임이 집중되어 있던 클래스에서 **몰라도 되는 세부사항을 다른 클래스 내부로 감춰 캡슐화**
        - 캡슐화는 객체의 자율성을 높이고, 응집도 높은 객체들의 공동체 창조
<br>

- **`의인화`** : 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙**
    - 현실에서는 수동적인 존재더라도 (ex. 가방, 매표소) 객체지향의 세계에서는 모든 것이 능동적이고 자율적 존재로 변한다
    - 일상에서는 어떤 사건이 일어나기 위해 반드시 `인간 에이전트`가 필요하지만, 객체들은 그들 자신의 체계 안에서 `능동적이고 자율적인 에이전트` 이다.
        
        → 의인화의 관점에서 소프트웨어를 생물로 생각하기 !
<br>
  
- **객체지향**
    - 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 설계의 첫걸음일뿐, 진정한 객체지향 설계는 협력하는 객체들 사이의 의존성을 적절하게 조절해서, 변경에 용이한 설계를 만드는 것

### 추가적인 질문이나 의문점


- pg32) TicketSeller가 TicketOffice 의 구현이 아닌 인터페이스에만 의존하게 됐다 → 이해안됨

### 이 장에서 얻은 것


- A 객체에서 B 객체에 접근하는 코드를 B 객체 내부로 옮겨서 캡슐화하자
    
    [ AS-IS ] 
    
    ```java
    class TicketSeller {
    	public void sellTo(Audience audience){
    		if(audience.getBag().hasInvitation()){...}
    	}
    }
    ```
    
    ```java
    class Audience {
    	private Bag bag;
    	...
    }
    ```

    [ TO-BE ]

    ```java
    class TicketSeller { 
        public void sellTo(Audience audience){
            if(audience.buy(ticketOffice.getTicket())) ...
    }
    ```

    ```java
    class Audience {
            private Bag bag;
            public Long buy(Ticket ticket){
                if(bag.hasInvitation()){...}
            }
    }
    ```
<br>

- 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다
    - 실세계에서 생명력이 없는 존재더라도, 객체지향 세계에서는 생명력을 갖게 하자
  
- 설계는 결국 트레이드오프의 산물이다.