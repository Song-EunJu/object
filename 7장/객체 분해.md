### 객체 분해

- 복잡성을 해결하기 위해, **추상화**와 **분해**가 사용되어 왔음
- 프로그래밍 언어를 특정 짓는 2가지 추상화 메커니즘
    - 프로시저 추상화 : 소프트웨어가 `무엇을 해야하는지` 추상화
        - 기능 분해
    - 데이터 추상화 : 소프트웨어가 `무엇을 알아야 하는지` 추상화
        - 데이터 중심으로 타입을 추상화  → 추상 데이터 타입
        - 데이터 중심으로 프로시저를 추상화 → 객체지향
- 역할과 책임을 수행하는 객체 : 추상화
- 기능을, ‘협력하는 공동체’ 를 구성하도록 객체들로 나누는 과정 : 분해
- 즉, 객체지향은 데이터 추상화 / 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것

### 프로시저 추상화와 기능 분해

- 프로시저 : 반복 실행 및 유사 실행 작업들을 한 장소에 모아놓아, 로직 재사용하고 중복을 방지할 수 있는 추상화 방법
    - 상세 구현을 몰라도, 인터페이스만 알면 프로시저를 사용할 수 있어서 잠재적인 정보은닉이 가능함
- 전통적 기능 분해 방법은 하향식 접근 (Top-Down 방식) 을 따름
    - 상위 기능은 하나 이상의 더 간단하고, 더 구체적이며, 덜 추상적인 하위 기능 집합으로 분해됨
- 기능 분해의 초점은, **하나의 문장으로 표현된 기능을 여러 개의 더 작은 기능으로 분해**하는 것
    - 모든 문장이 정제 과정을 거치면서, 하나 이상의 단순하고 구체적인 문장 조합으로 분해되어야 함
    - 충분히 저수준이 될 때까지 해야 함
- 기능 분해에서는 `기능` 을 중심으로 기능을 구현하기 위해 필요한 `데이터` 를 결정
- 하향식 기능 분해는, 시스템을 최상위의 가장 `추상적인 메인함수` 로 정의하고, 메인 함수를 구현 가능한 수준까지 `세부적인 단계` 로 분해하는 방법
    - 이렇게 설계한 시스템은 메인 함수를 루트로 하는 **트리**로 표현 가능
 

### 하향식 기능분해의 문제점
1. 하나의 메인함수? 현실적으로 불가능하다
    - 모든 기능을 자식 노드로 갖는 하나의 메인 기능을 선택하는 것은 생각보다 어렵다
2. 요구사항 변경으로 인한 메인함수의 빈번한 수정이 필요하다
    - 새로운 정상 (메인기능) 이 추가될 때마다, **메인함수의 내부 구현을 수정할 수 밖에** 없어짐<br>
    ex) 기존 메인함수에서 분기를 쳐서, 적절한 경우에 두개의 정상을 선택적으로 호출하도록 수정해야 함
3. 비즈니스 로직과 UI 가 결합된다
    - ‘급여 계산’ 이라는 `비즈니스 로직` 과 관련된 관심사와 ‘소득 세율을 입력받아 결과를 화면에 출력’ 이라는 `사용자 인터페이스` 관심사가 섞여있음
    - 사용자 인터페이스는 변경이 잦은데, 이 때마다 비즈니스 로직까지 영향을 받아서 불안정한 아키텍처가 되며 “관심사의 분리” 라는 목적 달성 실패
