## 12장 : 다형성

- 상속의 목적 ≠ 코드 재사용, **타입 계층을 구조화**하기 위함!
    - 타입 계층은 다형성의 기반을 제공함
- 상속을 사용하려는 목적이 단순히 코드 재사용이라면 사용하지 마라. 클라이언트 관점에서 **인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서**라면 사용하라
- 다형성 : 런타임에 **메시지를 처리하기에 적합한 메소드**를 `동적으로 탐색`하는 과정을 통해 구현됨
- 상속 : 이런 **메소드를 찾기 위한 일종의 탐색 경로**를, `클래스 계층` 형태로 구현하기 위한 방법

### 다형성

- 다형성이란 **추상 인터페이스**에 대해 코드를 작성하고, 추상 인터페이스에 대해 **서로 다른 구현을 연결**할 수 있는 능력
    - **여러 타입을 대상으로 동작**할 수 있는 코드 작성하는 방법
- 다형성
    - 유니버설
        - 매개변수
            - 제네릭 프로그래밍과 관련있는데, 임의의 타입으로 선언 후 **사용하는 시점에 구체적인 타입**으로 지정하는 방식
            - 다양한 타입의 요소를 다루기 위해 **동일한 오퍼레이션** 사용 가능
        - 포함
            - 메시지가 동일해도, **수신한 객체 타입에 따라 실제로 수행되는 행동이 달라지는** 능력
            - `서브타입 다형성`이라고도 불림
                - 이 다형성을 구현하는 가장 일반적인 방법 : 상속 사용하기
                - 포함 다형성을 위한 전제조건은, 자식 클래스가 부모 클래스의 서브타입이어야 한다는 것!
                - 상속의 진정한 목적은 코드 재사용이 아니라, **다형성을 위한 서브타입 계층을 구축하는 것**!
                - 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는, 상속이 **클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메소드를 선택할 수 있는 메커니즘을 제공하기 때문** (객체가 메시지 수신 시, 메시지를 처리할 적절한 메소드를 상속 계층 안에서 탐색함)
    - 임시
        - 오버로딩
            - 하나의 클래스 안에 동일한 이름의 메소드가 존재하는 경우에 사용하여, **유사한 작업 수행하는 메소드 이름을 통일**할 수 있음
        - 강제
            - 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
            ex) ‘+’ 연산자가 덧셈 연산자, 문자열 연결 연산자로 사용되는 경우

### 상속의 양면성

- **데이터** 관점의 상속 : 부모 클래스에서 정의한 모든 `데이터`를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있음
    - 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있음
- **행동** 관점의 상속 : 부모 클래스에서 정의한 일부 `메소드`를 자동으로 자식 클래스에 포함시킬 수 있음
    - 데이터와 행동 관점에서만 바라보면, 상속이 부모 클래스에서 사용한 데이터/행동을 자식클래스에서 자동적으로 공유할 수 있는 재사용 메커니즘으로 보이는게 당연함
<br>

- 부모 클래스, 자식클래스에 동일한 시그니처 가진 메소드가 존재할 경우, 자식 클래스 메소드의 우선순위가 더 높다

### 행동 관점의 상속

![Untitled](https://velog.velcdn.com/images%2Fviewrain%2Fpost%2Fd8e8abfa-a744-47f7-97de-0b03a67f7963%2Fimage.png)

- 공통적으로 부모 클래스의 모든 퍼블릭 메소드는 자식 클래스의 퍼블릭 인터페이스에 포함됨
- 어떻게 부모 클래스에서 구현한 메소드가 자식 클래스의 인스턴스에서 수행할 수 있는 걸까?
    - **런타임에** 시스템이 **자식 클래스에 정의되지 않은 메소드가 있을 경우, 메소드를 부모 클래스에서 탐색하기 때문**
- 객체는 `서로 다른 상태` 를 저장할 수 있도록, 각 인스턴스별로 `독립적인 메모리를 할당`받아야 함
- 메소드는 동일한 클래스의 인스턴스끼리 공유가 가능하므로, 클래스는 `1번만 메모리에 로드`하고, 각 인스턴스별로 클래스를 가리키는 `포인터` 를 갖게 함
<br>

- 각 객체는 자신의 클래스인 Lecture 위치를 가리키는 class 라는 이름의 포인터를 가지며, 이 포인터로 자신의 클래스 정보에 접근 가능
- Lecture 클래스는 자신의 부모 클래스인 Object 위치를 가리키는 parent 라는 이름의 포인터를 가짐
- 이 포인터를 이용하면, 클래스의 **상속 계층을 따라 부모 클래스의 정의로 이동하는 것**이 가능
- 자식 클래스의 인스턴스를 통해 어떻게 부모 클래스에 정의된 메소드를 실행할 수 있는가?
    - 메시지를 수신한 객체는 class 포인터로 연결된 자신의 클래스에서 적절한 메소드가 존재하는지 찾는다
    - 존재하지 않으면 클래스의 parent 포인터를 따라 부모 클래스를 차례대로 훑어가면서 메소드 탐색
    - 각 객체에 포함된 class 포인터, 클래스에 포함된 parent 포인터를 조합하여, 현재 인스턴스 클래스 ~ 최상위 부모 클래스에 이르기까지 모든 `부모클래스 접근` 이 가능함
 
### 업캐스팅과 동적바인딩

- 선언된 참조 타입과 무관하게, 실제로 메시지를 수신하는 객체타입에 따라 실행되는 메소드가 달라질 수 있는 것은 `업캐스팅` 과 `동적바인딩` 이라는 메커니즘 때문
- `업캐스팅` : 부모 클래스 타입으로 선언된 변수에 **자식 클래스의 인스턴스 할당하는 것**이 가능
    - 컴파일러는 명시적인 타입 변환 없이도, 자식 클래스가 부모 클래스 대체할 수 있게 허용
    - 따라서 부모클래스와 협력하는 클라이언트는, **미래의 자식클래스들과도 협력할 수 있는** 무한한 확장 가능성을 가짐
- `동적 바인딩` : 선언된 변수 타입이 아니라, **메시지 수신하는 객체 타입에 따라 실행되는 메소드가 결정**됨
    - 객체 지향 시스템이 메시지를 처리할 메소드를 `컴파일 시점이 아니라` **런타임에 결정하기 때문에** 가능한 것 
    - “함수를 호출” 하는 전통적인 언어는 호출될 함수를 “컴파일 타임” 에 결정 == 코드를 작성하는 시점에 호출될 코드가 결정됨
   <br> → 정적 바인딩 (static binding) / 초기 바인딩 (early binding) / 컴파일타임 바인딩
    - “메시지를 전송” 하는 객체지향 언어는 메시지를 수신했을 때 실행되는 메소드가 “런타임”에 결정 <br>
    → 동적 바인딩 (dynamic binding) / 지연 바인딩 (late binding)
- 업캐스팅, 동적바인딩은 코드 변경 없이 기능 추가 가능하게 하므로, 개방-폐쇄 원칙을 이루기 위한 방법 중 하나이다
- 업캐스팅, 동적바인딩을 이용하면 부모 클래스 참조에 대한 메시지 전송을 **자식 클래스에 대한 메소드 호출로 변환 가능**하다

### 동적 메소드 탐색과 다형성

- 객체가 메시지 수신하면 컴파일러는 `self 참조` 라는 임시변수를 자동 생성한 후, 메시지 수신한 객체를 가리키도록 설정
- 동적 메소드 탐색은, **self 가 가리키는 객체의 클래스에서 시작**해서 상속 계층의 역방향 (자식 → 부모) 으로 이루어지며, 메소드 탐색 종료 시 self 참조는 자동 소멸
    - 자식클래스 메소드가 부모클래스 메소드보다 먼저 탐색됨

### 이해할 수 없는 메시지

- 객체가 자신이 이해할 수 없는 메시지를 처리하는 방법은 정적 타입 언어인지, 동적 타입 언어인지에 따라 달라짐
- **정적 타입 언어** : 코드 `컴파일` 시 상속 계층 안의 클래스들이 메시지 이해할 수 있는지 여부를 판단
    - 상속 계층 전체 탐색 후에도 메시지 처리하는 메소드 발견 못할 경우, `컴파일 에러` 발생
- **동적 타입 언어** : 컴파일 단계가 존재하지 않기 때문에, 실제 코드 실행해보기 전에는 `메시지 처리 가능 여부를 판단할 수 없음`
    - 몇 가지 동적타입 언어는, 메소드를 처리할 수 없음을 알게 되면 self 참조가 가리키는 현재 객체에게 이해할 수 없다는 메시지 전송
    - 해당 메시지 역시 self 참조가 가리키는 객체 클래스부터 상속 계층을 끝까지 올라가면서 탐색
    - 만약 여기서도 메시지를 처리할 클래스가 없다면 최종적으로 예외가 던져짐

### Self 대 Super

- self 참조는 메시지를 수신한 객체의 클래스에 따라, **메소드 탐색을 위한 문맥을 실행시점에 결정**
- super 참조를 이용해 부모 클래스에게 evaluate 메시지를 전송한다.
    - 여기서 부모 클래스의 ‘메소드 호출’ 이 아니라 부모 클래스에게 ‘메시지 전송’ 이라는 표현을 사용했는데, 
    super.evaluate() 은 단순히 부모 클래스의 evaluate 메소드를 호출하는 것이 아니고 **더 상위에 위치한 조상 클래스 메소드일 수 있음**
    - super 참조의 용도는 **부모 클래스에 정의된 메소드를 실행하기 위함이 아니라**, “**지금 이 클래스의 부모클래스에서부터 메소드 탐색을 시작하세요**” 이다
        - 부모 클래스에서 원하는 메소드 찾지 못하면, 더 상위로 이동하여 메소드 존재하는지 검사
    - 부모 클래스의 `메소드 호출` vs. 부모클래스에서 `메소드 탐색 시작` 은 의미가 매우 다름
        - 메소드 호출 : 그 메소드가 반드시 부모 클래스 안에 정의되어 있어야 함
        - 메소드 탐색 시작 : 클래스 조상 어딘가에 그 메소드가 정의되어있기만 하며 실행가능함
- self 전송 : 메시지 수신하는 **객체의 클래스에 따라** 메소드를 탐색할 **시작 위치 동적 결정**
    - 메소드 탐색 시작하는 클래스가 미정이어서, 런타임에 동적으로 결정되어야 함
- super 전송 : 메시지를 전송하는 **클래스의 부모 클래스에서부터** 시작
    - 메소드 탐색 시작하는 클래스를 컴파일 시점에 미리 결정해둘 수 있음

### 상속 대 위임

- 상속 : 자식클래스 인스턴스 안에 부모클래스 인스턴스 포함하는 것으로 표현 가능
- `자식클래스` 인스턴스 입장에서 **self 참조는 자식 클래스 인스턴스 자신**을 가리킨다
- 자식클래스 인스턴스 내에 포함된 `부모클래스` 인스턴스 입장에서 **self 참조 또한  자식 클래스 인스턴스를** 가리킨다
- **self 참조는 항상 메시지를 수신한 객체를 가리키기 때문** (따라서 메소드 탐색 중에는 자식클래스, 부모클래스 인스턴스가 동일한 self 참조를 공유하는 것으로 봐도 무방함)
- `위임` (delegation) : 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리 요청하는것
    - 자신이 정의하지 않았거나, 처리할 수 없는 속성 또는 메소드 탐색 과정을 다른 객체로 이동시키기 위해 사용
    - 따라서 항상 현재의 실행 문맥을 가리키는 self 참조를 인자로 전달
- 포워딩 : self 참조를 전달하지 않는 경우
- 위임 : self 참조를 전달하는 경우
- 상속은 동적으로 메소드를 탐색하기 위해 현재 실행 문맥을 가지고 있는 **self 참조를 전달**하며, 객체들 사이에서 **메시지 전달과정은 자동으로** 이루어지므로 `자동적인 메시지 위임`이라고 부르는 것이다
- 자바스크립트는 클래스가 존재하지 않고 오직 객체만 존재하는 **프로토타입 기반의 객체지향 언어**인데, 이런 언어에서 상속을 구현하는 유일한 방법은 **객체 사이의 위임을 이용하는 것**
    - 객체지향 패러다임에서 클래스가 필수요소가 아니라는 점을 보여줌
    - 상속 이외의 방법으로도 다형성을 구현할 수 있다는 점을 보여줌