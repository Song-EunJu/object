## 12장 : 다형성

- 상속의 목적 ≠ 코드 재사용, **타입 계층을 구조화**하기 위함!
    - 타입 계층은 다형성의 기반을 제공함
- 상속을 사용하려는 목적이 단순히 코드 재사용이라면 사용하지 마라. 클라이언트 관점에서 **인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서**라면 사용하라
- 다형성 : 런타임에 **메시지를 처리하기에 적합한 메소드**를 `동적으로 탐색`하는 과정을 통해 구현됨
- 상속 : 이런 **메소드를 찾기 위한 일종의 탐색 경로**를, `클래스 계층` 형태로 구현하기 위한 방법

### 다형성

- 다형성이란 **추상 인터페이스**에 대해 코드를 작성하고, 추상 인터페이스에 대해 **서로 다른 구현을 연결**할 수 있는 능력
    - **여러 타입을 대상으로 동작**할 수 있는 코드 작성하는 방법
- 다형성
    - 유니버설
        - 매개변수
            - 제네릭 프로그래밍과 관련있는데, 임의의 타입으로 선언 후 **사용하는 시점에 구체적인 타입**으로 지정하는 방식
            - 다양한 타입의 요소를 다루기 위해 **동일한 오퍼레이션** 사용 가능
        - 포함
            - 메시지가 동일해도, **수신한 객체 타입에 따라 실제로 수행되는 행동이 달라지는** 능력
            - `서브타입 다형성`이라고도 불림
                - 이 다형성을 구현하는 가장 일반적인 방법 : 상속 사용하기
                - 포함 다형성을 위한 전제조건은, 자식 클래스가 부모 클래스의 서브타입이어야 한다는 것!
                - 상속의 진정한 목적은 코드 재사용이 아니라, **다형성을 위한 서브타입 계층을 구축하는 것**!
                - 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는, 상속이 **클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메소드를 선택할 수 있는 메커니즘을 제공하기 때문** (객체가 메시지 수신 시, 메시지를 처리할 적절한 메소드를 상속 계층 안에서 탐색함)
    - 임시
        - 오버로딩
            - 하나의 클래스 안에 동일한 이름의 메소드가 존재하는 경우에 사용하여, **유사한 작업 수행하는 메소드 이름을 통일**할 수 있음
        - 강제
            - 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
            ex) ‘+’ 연산자가 덧셈 연산자, 문자열 연결 연산자로 사용되는 경우

### 상속의 양면성

- **데이터** 관점의 상속 : 부모 클래스에서 정의한 모든 `데이터`를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있음
    - 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있음
- **행동** 관점의 상속 : 부모 클래스에서 정의한 일부 `메소드`를 자동으로 자식 클래스에 포함시킬 수 있음
    - 데이터와 행동 관점에서만 바라보면, 상속이 부모 클래스에서 사용한 데이터/행동을 자식클래스에서 자동적으로 공유할 수 있는 재사용 메커니즘으로 보이는게 당연함
<br>

- 부모 클래스, 자식클래스에 동일한 시그니처 가진 메소드가 존재할 경우, 자식 클래스 메소드의 우선순위가 더 높다

### 행동 관점의 상속

![Untitled](https://velog.velcdn.com/images%2Fviewrain%2Fpost%2Fd8e8abfa-a744-47f7-97de-0b03a67f7963%2Fimage.png)

- 공통적으로 부모 클래스의 모든 퍼블릭 메소드는 자식 클래스의 퍼블릭 인터페이스에 포함됨
- 어떻게 부모 클래스에서 구현한 메소드가 자식 클래스의 인스턴스에서 수행할 수 있는 걸까?
    - **런타임에** 시스템이 **자식 클래스에 정의되지 않은 메소드가 있을 경우, 메소드를 부모 클래스에서 탐색하기 때문**
- 객체는 `서로 다른 상태` 를 저장할 수 있도록, 각 인스턴스별로 `독립적인 메모리를 할당`받아야 함
- 메소드는 동일한 클래스의 인스턴스끼리 공유가 가능하므로, 클래스는 `1번만 메모리에 로드`하고, 각 인스턴스별로 클래스를 가리키는 `포인터` 를 갖게 함
<br>

- 각 객체는 자신의 클래스인 Lecture 위치를 가리키는 class 라는 이름의 포인터를 가지며, 이 포인터로 자신의 클래스 정보에 접근 가능
- Lecture 클래스는 자신의 부모 클래스인 Object 위치를 가리키는 parent 라는 이름의 포인터를 가짐
- 이 포인터를 이용하면, 클래스의 **상속 계층을 따라 부모 클래스의 정의로 이동하는 것**이 가능
- 자식 클래스의 인스턴스를 통해 어떻게 부모 클래스에 정의된 메소드를 실행할 수 있는가?
    - 메시지를 수신한 객체는 class 포인터로 연결된 자신의 클래스에서 적절한 메소드가 존재하는지 찾는다
    - 존재하지 않으면 클래스의 parent 포인터를 따라 부모 클래스를 차례대로 훑어가면서 메소드 탐색
    - 각 객체에 포함된 class 포인터, 클래스에 포함된 parent 포인터를 조합하여, 현재 인스턴스 클래스 ~ 최상위 부모 클래스에 이르기까지 모든 `부모클래스 접근` 이 가능함
 
### 업캐스팅과 동적바인딩

- 선언된 참조 타입과 무관하게, 실제로 메시지를 수신하는 객체타입에 따라 실행되는 메소드가 달라질 수 있는 것은 `업캐스팅` 과 `동적바인딩` 이라는 메커니즘 때문
- `업캐스팅` : 부모 클래스 타입으로 선언된 변수에 **자식 클래스의 인스턴스 할당하는 것**이 가능
- `동적 바인딩` : 선언된 변수 타입이 아니라, **메시지 수신하는 객체 타입에 따라 실행되는 메소드가 결정**됨
    - 객체 지향 시스템이, 메시지를 처리할 메소드를 컴파일 시점이 아니라 **런타임에 결정하기 때문에** 가능한 것
- 업캐스팅, 동적바인딩은 코드 변경 없이 기능 추가 가능하게 하므로, 개방-폐쇄 원칙을 이루기 위한 방법 중 하나이다
