## 부록 C : 동적인 협력, 정적인 코드

- 객체는 동적이고, 프로그램은 정적이다.
    - 프로그램은 고정된 텍스트라는 형식에 갇혀 있으면서도 객체의 모든 변화 가능성을 담아야 함
- `동적모델` : 프로그램 실행 구조를 표현하는 움직이는 모델 / 객체, 협력
- `정적모델` : 코드의 구조를 담는 고정된 모델 / 타입, 관계
    - 타입 : 객체를 분류하기 위한 틀로서, 동일한 타입에 속하는 객체들이 수행할 수 있는 모든 행동들을 압축해서 표현
- 정적 모델은 동적 모델에 의해 주도되어야 하고, 동적 모델이라는 토대 위에 세워져야 함
    - 정적 모델은 결국 객체 사이의 협력에 기반해야 함
- 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 할 요소는 `변경` 이고, 변경을 수용할 수 있는 단순하고, 결합도가 낮고, 중복이 없는 코드를 만들어야 함
    - 수정이 용이한 코드 : 응집도가 높고, 결합도가 낮으며, 단순해서 쉽게 이해할 수 있는 코드
    - 유연한 코드 : 동일한 코드로 다양한 컨텍스트에서 동작 가능한 협력을 만들 수 있는 코드

### 동적 모델과 정적 모델

- 객체의 `행동` 이 정적 모델을 결정해야 한다
- 객체가 외부에 제공하는 행동을 제외한 채, 개념 사이의 관계에 기반해 정적 모델을 구상한다면
Penguin 을 Bird 의 자식 클래스로 구현할 것이다
    - 하지만, 객체가 외부에 fly 라는 행동을 제공하면, Bird > FlyingBird + Penguin 으로 나누어 상속계층이 구성되어야 함
    - 리스코프 치환 원칙에 따라 **클라이언트 관점에서 대체 가능성을 제공해야 하기 때문**
- 객체의 정적 모델은 동적 모델이라는 토대 없이는 완전해질 수 없으며, 정적 모델을 설계하는 이유는 **단지 행동과 변경을 적절히 수용 가능한 코드 구조를 찾는 것**

### 변경을 고려하라

- 행동 측면에서 적절하게 정적 모델을 고려하더라도, **변경을 고려하지 않는다면** 유지보수하기 어려운 코드가 만들어짐
    - 동일한 행동을 제공하는 정적모델이 있으면, 항상 현재 설계에서 요구되는 변경을 부드럽게 수용가능한 설계를 선택하라
- 도메인 모델을 먼저 만들고, 그것을 기반으로 설계와 구현을 진행하라는 말은 뭘까?
    - 도메인 모델은 결국 정적모델에 속한게 아닌가? 그렇다면 정적모델이 동적 모델에 기반하는 게 아니라 그 반대가 아닌가?
