## 부록 C : 동적인 협력, 정적인 코드

- 객체는 동적이고, 프로그램은 정적이다.
    - 프로그램은 고정된 텍스트라는 형식에 갇혀 있으면서도 객체의 모든 변화 가능성을 담아야 함
- `동적모델` : 프로그램 실행 구조를 표현하는 움직이는 모델 / 객체, 협력
- `정적모델` : 코드의 구조를 담는 고정된 모델 / 타입, 관계
    - 타입 : 객체를 분류하기 위한 틀로서, 동일한 타입에 속하는 객체들이 수행할 수 있는 모든 행동들을 압축해서 표현
- 정적 모델은 동적 모델에 의해 주도되어야 하고, 동적 모델이라는 토대 위에 세워져야 함
    - 정적 모델은 결국 객체 사이의 협력에 기반해야 함
- 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 할 요소는 `변경` 이고, 변경을 수용할 수 있는 단순하고, 결합도가 낮고, 중복이 없는 코드를 만들어야 함
    - 수정이 용이한 코드 : 응집도가 높고, 결합도가 낮으며, 단순해서 쉽게 이해할 수 있는 코드
    - 유연한 코드 : 동일한 코드로 다양한 컨텍스트에서 동작 가능한 협력을 만들 수 있는 코드

### 동적 모델과 정적 모델

- 객체의 `행동` 이 정적 모델을 결정해야 한다
- 객체가 외부에 제공하는 행동을 제외한 채, 개념 사이의 관계에 기반해 정적 모델을 구상한다면
Penguin 을 Bird 의 자식 클래스로 구현할 것이다
    - 하지만, 객체가 외부에 fly 라는 행동을 제공하면, Bird > FlyingBird + Penguin 으로 나누어 상속계층이 구성되어야 함
    - 리스코프 치환 원칙에 따라 **클라이언트 관점에서 대체 가능성을 제공해야 하기 때문**
- 객체의 정적 모델은 동적 모델이라는 토대 없이는 완전해질 수 없으며, 정적 모델을 설계하는 이유는 **단지 행동과 변경을 적절히 수용 가능한 코드 구조를 찾는 것**

### 변경을 고려하라

- 행동 측면에서 적절하게 정적 모델을 고려하더라도, **변경을 고려하지 않는다면** 유지보수하기 어려운 코드가 만들어짐
    - 동일한 행동을 제공하는 정적모델이 있으면, 항상 현재 설계에서 요구되는 변경을 부드럽게 수용가능한 설계를 선택하라
- 도메인 모델을 먼저 만들고, 그것을 기반으로 설계와 구현을 진행하라는 말은 뭘까?
    - 도메인 모델은 결국 정적모델에 속한게 아닌가? 그렇다면 정적모델이 동적 모델에 기반하는 게 아니라 그 반대가 아닌가?

### 도메인 모델과 구현

- `도메인 모델` : 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화, 의식적으로 구조화한 형태
- 소프트웨어의 도메인에 대해 고민 후, 도메인 모델을 기반으로 소프트웨어를 구축하라
    - 이 지침을 따르면, **개념과 소프트웨어 사이의 표현적 차이를 줄여** 이해하고 수정이 쉬운 소프트웨어를 만들 수 있음
    - 도메인 모델은 소프트웨어를 만드는 데 필요한 개념 이름, 의미, 관계에 대한 힌트를 제공하는 역할로 끝나야 한다
- 도메인 모델이 클래스 다이어그램과 같은 정적 모델에 기반해야 한다는 오해 역시 잘못된 코드 구조를 낳는다. <br>
→ 도메인 모델은 **도메인에 대한 지식을 표현하고, 코드 구조에 대한 힌트를 제공할 수 있으면 어떤 형태로 표현하더라도 상관 없다**
- 중요한 것은 `객체들의 협력을 지원하는` 코드 구조를 만드는 것, 도메인 개념을 충실히 따르는 코드가 목적이 아님

### 몬스터 설계하기

```java
public abstract class Monster { 
	private int health;
	abstract public String getAttack();
}
```

```java
public class Dragon extends Monster {
	public Dragon() {
		super(230);
	}

	@Override
	public String getAttack() {
		return "용은 불을 내뿜는다";
	}
}
```

- 위 경우에는 **새로운 몬스터가 추가될 때 하나의 클래스를 추가하고 getAttack 메서드를 오버라이딩**해야 함
    - 변경하기 어려운 이유 : 새로운 몬스터 필요 → 새로운 클래스 추가
    - 변경하기 쉬우려면 : 새로운 클래스 추가 없이도 새로운 몬스터를 추가할 수 있어야 함
    - 새로운 서브클래스 추가 대신 몬스터가 품종을 갖도록! == Monster 가 Breed 를 합성 관계로 포함하도록!

```java
public class Breed {
	private String name;
	private int health;
	private String attack;
}
```

```java
public class Monster {
	private int health;
	private Breed breed;
	
	public Monster(Breed breed) {
		this.health = breed.getHealth();
	}
}
```

```java
Monster dragon = new Monster(new Breed("용", 230, "용은 불을 내뿜는다"));
```

- 위 경우에는 **새로운 몬스터 종류를 추가하는 것 ≠ 새로운 클래스 추가, 새로운 Breed 인스턴스 생성하고 Monster 인스턴스에 연결하는 작업**
    - 상속 대신 합성을 사용하라는 설계 지침을 따르는 또다른 예시
    - 새로운 클래스를 추가하는 대신 Breed 의 새로운 인스턴스 생성하는 것으로 타입 추가 문제 해결 !
        - 타입을 인터페이스나 클래스로 구현한 것이 아니라, 타입을 표현하는 클래스의 인스턴스로 구현한 것 (즉, 어떤 객체의 타입을 표현하는 별도의 객체를 이용해 타입을 구현한 것)
        - 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방법 : `TYPE OBJECT` 패턴
    - 새로운 클래스 추가하는 작업을 **인스턴스 생성**으로 대체한 것과 동일

### 행동과 변경을 고려한 도메인 모델

- 구현하거나 변경하기 더 쉬운 모델이 떠올랐다면 과감하게 초기 아이디어를 버려라
- 도메인 모델은 단순한 클래스 다이어그램이 아니다.
    - **도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것**이 도메인 모델
    - 형식은 중요하지 않으며, 중요한 것은 전달하려는 의미이다
- 도메인 모델은 단순히 정적 모델 형태 띨 필요 없고, 도메인 모델 구조가 코드와 다를 필요가 없다
- 도메인 모델을 봤을 때 **도메인의 개념 + 코드도 함께 이해될 수 있는 구조를 찾는 것**

### 분석 모델, 설계 모델, 구현 모델

- **분석 모델** : 해결 방법에 대한 언급 없이 문제 도메인을 설명하는 모델
- **설계 모델** : 분석 모델 완성 시, 이를 바탕으로 기술적 관점에서 솔루션을 서술하는 모델
- **구현 모델** : 분석, 설계 모델을 기반으로 구현 모델을 만들어 프로그래밍 언어로 변환
- 도메인 모델이 코드와 동일한 형태라는 것 == 분석, 설계, 구현에 걸쳐 동일한 모델을 사용한다는 것
    - 소프트웨어 개발하는 전체주기 동안 동일한 설계 기법, 모델링 방법을 사용할 수 있다는 것
- 코드와 모델 차이를 줄이려면, 도메인과 코드 간의 차이가 적어야 한다 <br>
→ 객체지향은 이 방법이 동일하다
    - 코드는 도메인의 **개념적 분류 체계가 아니라 객체의 행동, 변경에 영향을 받는다**
- 전체 개발주기에 걸쳐 동일한 기법, 표현력을 유지할 수 있는 것이 객체지향 패러다임의 강력한 힘이므로 **분석/설계/구현 단계에서 모든 단계에 걸쳐 행동과 변경에 초점을 맞춰라**
