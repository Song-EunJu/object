## 5장 : 책임 할당하기

### 책임주도 설계

- `책임` (이 객체가 수행해야 하는 행동) 을 먼저 결정한 후에 객체의 `상태`를 결정
- 객체 입장에서 책임이 어색해보여도, 협력에 적합하다면 그 책임은 좋은 책임
    - **책임은** 객체의 입장이 아니라, **객체가 참여하는 협력에 적합해야 한다**
    - 협력에 적합한 책임 == `메시지 전송자`에게 적합한 책임
    - 메시지 전송하는 클라이언트의 의도에 적합한 책임을 할당해라
- 메시지 전송자는 어떤 객체가 메시지 수신자가 될지 알지 못하기 때문에, 전송자 입장에서는 수신자가 캡슐화됨
    - 누군가가 수신할거라는 걸 믿고 자신의 의도를 표현한 메시지를 전송할 뿐

### GRASP 패턴

- GRASP : General Responsibiltiy Assignment Software Pattern
    - 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합

### **책임을 할당해야 할 때 고민해야 하는 후보들**

1. **도메인 개념**
    - 설계를 시작하기 위해 참고할 수 있는 개념들의 모음 정도로 생각하자
      
2. **정보 전문가**
    - 애플리케이션이 **제공해야 하는 기능 == 책임**이라고 생각하자<br>
        ex) 제공해야 하는 기능 == 영화 예매 <br>
        → 애플리케이션은 **영화 예매할 책임이 존재**<br>
    - 메시지는, **수신객체가 아니라 전송객체의 의도를 반영**해서 결정해야 함<br>
        Q1. **메시지를 전송하는 객체는 무엇을 원하는가?**  <br>
        A. 영화 예매 <br>
        → 메시지 이름 “예매하라” <br>
        ( 협력을 시작하는 객체가 미정인 상태로 시작됨 )
        
        Q2. **메시지 수신할 적합한 객체는 무엇인가?** <br>
        A. 책임을 수행할 정보를 알고있는 객체 == INFORMATION EXPERT (정보 전문가) <br>
        - 정보를 알고 있는 객체만이, 책임을 **`어떻게`** 수행할지 스스로 결정 가능
        - 객체가 자율적인 존재여야 함을 상기시킴
        - 정보를 알고 있다고 해서, 정보를 저장할 필요는 없음. 
여기서 정보는 데이터랑 다름 !!!!!!!!!!
        <br>
        
        - 1번 메시지 : 예매하라
            - 영화 예매에 필요한 정보를 가장 많이 아는 `상영` 에게 책임 할당
            - ‘예매하라’ 메시지 완료를 위해서는 ‘예매 가격 계산’ 필요
            - `상영` 은 가격 계산 정보를 모르기 때문에, 가격계산이 상영 객체가 원하는 바임.
            “가격을 계산하라” 라는 메시지 전송
        - 2번 메시지 : 가격을 계산하라
            - 가격을 계산하는 데 정보를 가장 많이 아는 `영화` 에게 책임 할당
            - ‘가격을 계산하라’ 메시지 완료를 위해서는 ‘할인조건에 따라 할인 여부를 판단하는 작업` 필요
            - `영화` 는 할인 조건에 대한 정보를 모르기 때문에 할인 여부를 판단할 수 없어서, 할인 조건에 대한 작업이 `영화` 객체가 원하는 바임. “할인 여부를 판단하라” 메시지 전송
        - 3번 메시지 : 할인 여부를 판단하라
            - `할인조건` 은 외부의 도움 없이, 자신의 데이터만으로 메시지 처리 가능

              
3. **낮은 결합도 ( Low Coupling ) / 높은 응집도 ( High Cohesion )**
    - 여러 설계 대안이 있을 때는, 낮은 결합도 / 높은 응집도를 유지할 수 있는 설계를 선택하라

4. **창조자 ( Creator )**
    - 영화 예매 협력 최종 결과물 : Reservation 인스턴스 생성
        - Reservation 인스턴스 생성할 책임을 가진 객체는?
        - Reservation (예매) 를 하는데 필요한 데이터 (상영 시간, 영화, 상영 순번 등) 를 Screening (상영) 이 가지고 있음 → Screening 이 Reservation 의 CREATOR 로 적절함
    - 객체를 생성할 책임을, 어떤 객체에게 할당할지에 대한 지침을 제공하는 패턴
    == 생성되는 객체와 연결되거나 **관련되는 객체에 해당 객체 생성 책임을 맡기는 것**
        - 이미 결합된 객체에게, 생성 책임할당하는 것은 전체적인 결합도에 영향 X <br>
        → 낮은 결합도 유지 가능 !
    - 아래 조건을 가장 많이 만족하는 객체에게 A 객체 생성 책임을 할당하라
        - B 가 A 객체를 포함하거나 참조
        - B 가 A 객체 기록
        - B가 A 객체 긴밀하게 사용
        - B가 A 객체 초기화하는데 필요한 데이터를 가짐
     
### 구현 예시

```java
public class Screening {
	public Reservation reserve(Customer customer, int audienceCount){...} // 1

	private Money calculateFee(int audienceCount) {
		return movie.calculateMovieFee(this).times(audienceCount);
	}
}
```

- 영화 예매 시스템에서, 상영 (Screening) 은 “영화를 예매하라” 라는 메시지를 처리해야 하며, Reservation 의 창조자
- Movie 에게 “가격을 계산하라” 메시지를 전송

### 구현 개선하기

- 변경에 취약한 클래스 == `코드를 수정해야 하는 이유를 1가지 이상` 갖는 클래스 == `응집도가 낮은` 클래스
    - DiscountCondition 은 3가지의 이유로 코드가 변경될 수 있음
    1. 새로운 할인 조건 추가
    2. 순번 조건 로직 변경
    3. 기간 조건 로직 변경
- 1개 이상의 이유로 변경되어야 한다면, **변경의 이유에 따라 클래스를 분리하라**
- 인스턴스 초기화 시점에 서로 다른 속성들을 초기화한다면, **함께 초기화되는 속성 그룹을 기준으로 클래스를 분리하라**
    
    ex) DiscountCondition 이 순번 조건 표현하는 경우, sequence 만 초기화
          DiscountCondition 이 기간 조건 표현하는 경우, week, startTime, endTime 만 초기화
    
- 메소드들이 사용하는 속성에 따라 그룹이 나뉜다면, **속성 그룹과 해당 그룹을 사용하는 메소드 그룹 기준으로 코드를 분리하라**
    
    ex) isSatisfiedBySequence 메소드는 sequence 사용 / week, startTime, endTime 사용 X
          isSatisfiedByPeriod 메소드는 week, startTime, endTime 사용 / sequence 사용 X
    

→ DiscountCondition 를 Sequence / Period Condition 두 클래스로 분리하면 응집도 높아짐

→ 하지만 Movie 클래스가 Sequence / Period Condition 두 클래스 양쪽에 결합되어 결합도도 높아짐 
    또한 새로운 할인조건을 추가하는 것이 더 어려워짐

### 다형성을 통한 코드 분리하기

- Movie 는 할인 가능 여부 반환 결과만 중요하지, Sequence / Period Condition 의 객체인지는 중요 X
- `역할` 은 `협력` 안에서 `대체 가능성` 을 의미하므로 Sequence / Period Condition 에 역할의 개념을 적용하면, 
Movie 가 구체적인 클래스는 알지 못하고, 오직 `역할` 에 대해서만 결합되도록 의존성을 제한할 수 있음
- 역할을 구현하기 위한 방법
    - 추상클래스 : **구현을 공유해야 할 필요**가 있는 경우
    - 인터페이스 : 구현은 공유하지 않고, 역할을 대체하는 **객체들의 책임만 정의**하고 싶은 경우
- **Polymorphism 패턴** : 객체의 타입에 따라 변하는 로직이 있을 경우, **타입을 명시적으로 정의**하고, **변화하는 행동을 각 타입의 책임으로 할당**하라
    - 타입 : Sequence Condition / Period Condition
    - 책임
        - Sequence Condition 의 책임 : 순번 할인 조건의 “할인 가능 여부를 판단하라”
        - Period Condition 의 책임 : 기간 할인 조건의 “할인 가능 여부를 판단하라”
- **Protected Variations 패턴** : 변경을 캡슐화하도록 책임을 할당하라
    - DiscountCondition 이라는 추상화가 구체적인 타입 (Sequence Condition / Period Condition) 을 캡슐화함
    - 따라서 새로운 DiscountCondition 이 추가되어도, Movie 에는 전혀 영향이 없음
        
        → 클래스를 변경에 따라 분리하고, 인터페이스를 이용해 변경을 캡슐화한 것
        
    - <새로운 할인정책 추가> 라는 변경 가능성이 높다면, 안정적인 인터페이스 뒤로 변경을 캡슐화하라

- 구현을 가이드할 수 있는 도메인 모델을 선택하라

### 변경과 유연성

- 할인 정책을 구현하기 위해 상속을 이용할 때는 → Movie > AmountDiscountMovie / PeriodDiscountMovie
할인 정책을 추가될 때마다 인스턴스 생성 다시 하고 복사하는 귀찮은 과정 반복됨
- 상속 대신 `합성` 을 사용하여, DiscountPolicy 를 독립적으로 분리하여 Movie 에 합성시킴

### 책임 주도 설계의 대안

- 책임 주도 설계가 어렵다면, 일단 최대한 빠르게 목적하는 기능을 수행하는 코드를 작성한 후 리팩토링하자
- 긴 메소드는 응집도가 낮음. 따라서 주석을 추가하는 대신, **메소드를 작게 분해**해서 각 메소드의 응집도를 높여라
    - 작고, 목적이 명확한 메소드들로 구성해서, 변경을 처리하기 위해 어떤 메소드를 수정해야 하는지 쉽게 파악하자
    - 작고, 목적이 명확하면 재사용하기 쉽다
    - 객체로 책임을 분배할 때, **메소드를 응집도 있는 수준으로 분해하는 것**부터 시작하라
        - 각 메소드를 적절한 클래스로 이동하기 쉬워지기 때문 !
    - 메소드를 분해한 이후에는, **메소드가 사용하는 데이터를 정의하고 있는 클래스로 이동**시켜라
        - 메소드를 다른 클래스로 이동시킬 때는, 인자에 정의된 클래스 중 하나로 이동하는 경우가 대부분임
