## 타입 계층의 구현

- 많은 사람들이 타입과 클래스가 동일한 개념이라고 오해한다.
- `타입 계층` : 동일 메시지에 대한 `행동 호환성` 을 전제로 하기에 앞으로 나올 방법은 타입 계층 구현 방법 + 다형성 구현 방법
    - 올바른 타입 계층이 되려면, 서브타입이 슈퍼타입을 대체할 수 있도록 리스코프 치환 원칙도 준수해야 함

### 클래스를 이용한 타입 계층 구현

- 타입은 객체의 `퍼블릭 인터페이스`를 가리키므로, **클래스는 객체의 타입과 구현을 동시에 정의하는 것**과 같음
    - ex) Phone 클래스는 Phone 타입을 구현한다
    - Phone 은 calculateFee 메시지에 응답할 수 있는 **타입을 선언**하는 동시에 **객체 구현을 정의**하고 있는 것
- 타입을 구현할 수 있는 방법이 단 1가지만 존재하는 경우, 타입과 클래스를 동일하게 취급해도 무방
    - 여기서 `타입의 구현 방법이 단 1가지` 가 중요한데, 타입 구현할 수 있는 다양한 방법이 존재하는 순간부터 클래스와 타입을 갈라지기 시작!!!!
    - ex) 구현은 다르지만 (타입을 구현할 수 있는 다양한 방법을 구현하려는 경우) Phone 과 동일한 타입으로 분류되는 객체가 필요한 경우
- 퍼블릭 인터페이스를 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 가장 간단한 방법 : `상속` 이용하기
- 상속 이용 시 자식 클래스가 부모 클래스 구현 + 퍼블릭 인터페이스 물려받을 수 있어 타입 계층 쉽게 구현 가능

### 인터페이스를 이용한 타입 계층 구현

- 인터페이스가 다른 인터페이스를 확장하도록 만들면, 슈퍼타입과 서브타입 간의 타입계층을 구성할 수 있다
- 여러 클래스가 동일한 타입을 구현할 수 있다
    - 같은 인터페이스를 구현하고 있어서, 동일한 `메시지`에 응답 가능
- 하나의 클래스가 여러 타입을 구현할 수 있다
    - 하나의 인스턴스가 여러 `인터페이스`를 구현 가능
- 인터페이스, 클래스를 조합하면 다중 상속의 딜레마에 빠지지 않으면서 단일 상속 계층으로 인한 결합도 문제도 피할 수 있음<br>
→ 인터페이스를 이용한 `타입 정의` , 클래스를 이용한 `객체 구현` ⇒ 클래스 상속 없이도 타입 계층 구현 가능!
<br>

- `타입` : 동일한 퍼블릭 인터페이스를 가진 객체들의 범주
- `클래스` : 타입에 속하는 객체들을 구현하기 위한 구현 메커니즘
- 결국 타입이 식별된 이후에, 타입에 속하는 객체를 구현하기 위해 클래스를 사용하는 것!
- **중요한 것은 객체가 외부에 제공하는 행동 (퍼블릭 인터페이스), 즉 타입을 기준으로 객체들의 계층을 설계해야 한다**
    - 타입이 아니라 클래스를 강조하면, 객체의 퍼블릭 인터페이스가 아닌 세부 구현에 결합된 협력 관계를 낳게 됨

### 추상 클래스를 이용한 타입 계층 구현

- 구체 클래스로 타입 정의해서 상속 받기 vs. 추상 클래스로 타입 정의해서 상속받기에는 2가지 차이점이 있음
1. **추상화의 정도**
    - 클래스로 타입 계층을 구현하는 경우)
        - calculateFee 메서드의 `구체적인 내부 구현` 에 강하게 결합됨
        - Phone 의 내부 구현 변경될 경우, 자식클래스도 함께 변경될 가능성이 높음
    - 추상클래스로 구현하는 경우)
        - 내부 구현이 아닌, 추상 메서드의 `시그니처` 에만 의존
        - 추상 메서드로 정의된 메서드를 오버라이딩하면 된다는 사실에만 의존해도 무방
- **모든 구체 클래스의 부모 클래스를 항상 추상클래스로 만들기 위해 노력하라**
    - **의존하는 대상이 더 추상적일수록**, 결합도는 낮아지고 변경으로 인한 영향도는 줄어든다
1. **상속을 사용하는 의도**
    - 추상클래스는 처음부터 상속을 염두에 두고 설계된 클래스
    - 자신의 인스턴스를 직접 생성할 수 없으므로, 추상클래스의 유일 목적은 자식 클래스를 추가하는 것
        - 클래스는 추상 메서드를 제공함으로써 상속계층을 쉽게 확장할 수 있게 함

### 추상 클래스와 인터페이스 결합하기
- 자바는 다중 상속이 불가능한데, 인터페이스를 이용해서 하나의 클래스가 하나 이상의 타입으로 분류 가능하도록 확장할 수 있음
- 자바 8 이전 버전에서는 **인터페이스에 구현 코드를 포함할 수 없어** 인터페이스만으로는 **중복 코드 제거하기 어렵다**는 문제가 있었음
- 골격 구현 추상 클래스 : `인터페이스` 를 이용해 `타입` 을 정의하고, 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우, `추상클래스` 를 이용해 코드 중복을 방지하는 것
    ```java
    public interface DiscountPolicy {
    		Money calculateDiscountAmount(Screening screening);
    }
    
    public abstract class **DefaultDiscountPolicy** implements DiscountPolicy {
    	  private List<DiscountCondition> conditions = new ArrayList<>();
    		
    		public DefaultDiscountPolicy(DiscountCondition... conditions) {
    				this.conditions = Arrays.asList(conditions);
    		}
    
    		@Override
        public Money calculateDiscountAmount(Screening screening) {
            for(DiscountCondition each : getConditions()) {
                if (each.isSatisfiedBy(screening)) {
                    return getDiscountAmount(screening);
                }
            }
    
            return screening.getMovieFee();
        }
    
        abstract protected Money getDiscountAmount(Screening screening);
    }
    ```
    
    ```java
    public class AmountDiscountPolicy extends DefaultDiscountPolicy {...}
    public class PercentDiscountPolicy extends DefaultDiscountPolicy {...}
    ```
    
- 인터페이스 + 추상클래스를 함께 사용하는 방법은, 추상 클래스만 사용하는 방법에 비해 2가지 장점이 있음
1. 다양한 구현방법이 필요할 경우, **새로운 추상 클래스를 추가**해서 쉽게 해결 가능
2. 이미 부모클래스가 존재하는 클래스더라도, 인터페이스를 추가함으로써 새로운 타입으로 쉽게 확장 가능
    - DiscountPolicy 와 같은 인터페이스를 하나 추가하고 DefaultDiscountPolicy 가 구현하도록 하면 됨
- **설계가 상속 계층에 얽매이지 않는 타입 계층을 요구한다면, 인터페이스로 타입을 정의하고 추상 클래스로 기본 구현 제공해서 중복 코드를 제거하라**

### 덕 타이핑 사용하기

- `덕 타이핑`은 주로 **동적 타입 언어**에서 사용하는 방법
- `덕 테스트` 는 객체가 어떤 인터페이스에 정의된 행동을 수행할 수만 있다면, 그 객체를 해당 타입으로 분류해도 문제가 없다는 것이다
- 자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일 타입으로 취급하기 위해서는 코드 상의 타입이 동일하게 선언되어 있어야 함
    - 동일한 시그니처 메서드를 포함한다고 같은 타입으로 판단하지 않음
    - **객체의 퍼블릭 인터페이스만으로 타입을 추측하는 거의 불가능하며, 모든 요소의 타입이 명시적으로 기술되어 있어야 함**
- 런타임에 타입을 결정하는 동적 타입 언어는 특정 클래스 상속받거나 인터페이스 구현 없이도, 객체가 수신할 수 있는 메시지 집합으로 객체의 타입을 결정할 수 있음
- 덕 타이핑은 `타입이 행동에 대한 것` 이라는 사실을 강조하며, 두 객체가 동일하게 행동할 경우 내부 구현은 상관없이 타입 관점에서 두 객체는 동일한 타입인 것
    - 클래스, 인터페이스에 대한 의존성 → `메시지에 대한 의존성`으로 대체함.
    - 즉, 낮은 결합도를 유지하고 변경에 유연하게 대응 가능
    - 하지만, **컴파일 시점에 발견할 수 있는 오류를 런타임으로 미루기 때문에** 설계의 유연성을 얻는 대신 **코드의 안전성을 약화**시킬 수 있음
- C++ 에서는 컴파일 타임 체크를 통해 타입 안전성을 보장하기도 함
    - 하지만, 호출되는 각각의 타입에 대해 함수의 복제본을 만들어서, 거대한 크기의 프로그램이라는 비효율성을 감수해야 함
 
### 믹스인과 타입 계층

- `믹스인` : 객체 생성 시 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브 클래스
    - 다양한 객체 구현 내에서 동일한 “행동” 을 **중복 코드 없이 재사용**할 수 있게 만듦
    - 믹스인으로 코드를 재사용하는 객체들은 동일한 `행동` 을 공유하며, 즉 동일한 `메시지` 를 수신할 수 있는 `퍼블릭 인터페이스` 를 공유하게 됨
- 믹스인은 간결한 인터페이스를 가진 클래스를 풍부한 인터페이스를 가진 클래스로 만들기 위해 사용됨
- 자바에서 `디폴트 메서드` 는 인터페이스에 **메서드의 기본 구현을 추가하는 것**을 허용
    - 추상 클래스가 제공하는 코드 재사용성 혜택을 누리면서도, 특정 상속 계층에 얽매이지 않는 인터페이스 장점 유지 가능

```java
public interface DiscountPolicy {
    **default** Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : **getConditions**()) {
            if (each.isSatisfiedBy(screening)) {
                return **getDiscountAmount**(screening);
            }
        }

        return screening.getMovieFee();
    }

    List<DiscountCondition> getConditions();
    Money getDiscountAmount(Screening screening);
}
```

- DiscountPolicy 인터페이스의 calculateDiscountAmount 를 디폴트 메소드로 구현하면, 기본 구현을 제공하기 위한 추상클래스를 만들지 않아도 됨 <br>
→ 하지만 디폴트 메서드가 가지는 한계는 분명히 있음
- DiscountPolicy 인터페이스를 구현하는 모든 클래스는 getConditions, getDiscountAmount 메서드**의 구현을 제공해야 함을 명시한 것** <br>
→ 하지만 이 메서드들이 **인터페이스에 정의되어 있어 클래스 내에 `퍼블릭 메서드`로 구현**되어야 함
    - getDiscountAmount 메서드가 원래는 구현을 위해 **추상 클래스 내부에서만 사용될 메서드라 protected** 였는데 public 으로 변경됨
    - 디폴트 메서드 안에서 사용된다는 이유만으로 public 메서드가 되어야 하며, 외부에 노출할 필요가 없는 메서드를 **불필요하게 퍼블릭 인터페이스에 추가**하게 됨
    - getConditions 메서드의 경우에는 클래스 내부에서 DiscountCondition 목록을 관리함을 공개할 뿐만 아니라, public 메서드로 제공함으로써 이 목록에 접근 가능하게 하여 **캡슐화를 약화**시킴
- 자바 8 에서 `디폴트 메서드` 를 추가한 이유가 **인터페이스로 추상클래스의 역할을 대체하려는 것이 아니기 때문에** 나타난 문제점
    - 디폴트 메서드가 추가된 이유는 추상 클래스를 제거하기 위함이 아니라, 기존에 널리 사용된 인터페이스에 새로운 오퍼레이션을 추가할 경우 발생하는 `하위 호환성 문제` 를 해결하기 위한 것
- 타입을 정의하는 기준 == 객체가 외부에 제공하는 퍼블릭 인터페이스
- 어떤 타입이 다른 타입의 서브타입이 되려면, 구현할 때 `리스코프 치환 원칙` 을 준수해야 함
- 타입 계층을 구현했더라도 리스코프 치환 원칙을 준수하지 않으면 올바른 타입 계층을 구현한 것이 아니며 코드 재사용과 서브타이핑을 혼동하고 있는 지 살펴보아야 함
