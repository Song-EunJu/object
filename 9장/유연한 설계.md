## 9장 : 유연한 설계

### 개방-폐쇄 원칙

- 확장에 열려 있다 : 새로운 `동작` 을 추가해서 기능 확장 가능
- 변경에 닫혀 있다 : 기존 코드의 `수정 없이` 동작 추가/변경 가능
- OCP 원칙은 런타임, 컴파일타임 의존성에 관한 이야기임
    - 의존성 관점에서 OCP 원칙을 따르는 설계란, **컴파일타임 의존성은 유지 / 런타임 의존성의 가능성 확장 + 수정할 수 있는 구조**
- OCP 의 핵심은 `추상화` 에 의존하는 것
    - 문맥이 바뀌더라도 **변하지 않는 부분** (추상화된 부분)
        - 남아있는 부분은 **수정에 대해 닫혀있음**
    - 문맥에 따라 **변하는 부분** (추상화 되지 않고 **생략된 부분**)
        - 생략된 부분은 **확장의 여지를 남김**
- 어떤 개념을 추상화했다고 해서, 수정에 닫힌 설계를 만들 수 있는 것은 아님
- **변하는 것과 변하지 않는 것이 무엇인지 이해하고 신중하게 결정하여 추상화하라**

### 생성 사용 분리

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = new AmountDiscountPolicy(...); // movie 가 인스턴스 생성 (CREATE) 
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening)); // movie 가 discountPolicy 객체에게 메시지 전송 (USE)
    }
}
```

- 동일한 클래스 내에서 객체 생성 / 사용이라는 2가지 목적을 가진 코드가 공존하는 것은 문제가 됨
    - 객체와 관련된 2가지 책임을 서로 다른 객체로 분리해야 함 → `생성과 사용을 분리` 하자
- 객체를 생성할 책임을 클라이언트로 옮겨서, Movie 가 특정 클라이언트에 결합되지 않고 독립적이게 하자

```java
public class Client {
    public Money getAvatarFee() {
        Movie avatar = new Movie("아바타",
                Duration.ofMinutes(120),
                Money.wons(10000),
                new AmountDiscountPolicy(
                    Money.wons(800),
                    new SequenceCondition(1),
                    new SequenceCondition(10)));
        return avatar.getFee();
    }
}

public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

- Movie 는 오직 DiscountPolicy 인스턴스를 사용하는 것에만 집중, 구체적인 컨텍스트와 관련된 정보 (AmountDiscountPolicy) 는 Client 에 있음
- Movie 객체 생성 책임을 Client 로 옮기게 되면, Client 또한 특정 컨텍스트에 묶이게 됨
    - 객체 생성과 관련된 책임만 전담하는 별도 객체를 추가하여 Client 가 이 객체를 사용하도록 함
    - `FACTORY` : 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체

```java
public class Factory { // 객체 생성을 전담으로 하는 클래스
    public Movie createAvatarMovie() {
        return new Movie("아바타", // CREATE
                Duration.ofMinutes(120),
                Money.wons(10000),
                new AmountDiscountPolicy(
                    Money.wons(800),
                    new SequenceCondition(1),
                    new SequenceCondition(10)));
    }
}

public class Client {
    private Factory factory;

    public Client(Factory factory) {
        this.factory = factory;
    }

    public Money getAvatarFee() {
        Movie avatar = factory.createAvatarMovie(); // USE
        return avatar.getFee();
    }
}
```

- Factory 를 사용하여 생성과 관련된 책임을 Factory 가 모두 처리하도록 함
- Client 는 오직 `사용` 과 관련된 책임만 지고, 생성과 관련된 어떤 지식도 갖지 않도록 함
