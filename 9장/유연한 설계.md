## 9장 : 유연한 설계

### 개방-폐쇄 원칙

- 확장에 열려 있다 : 새로운 `동작` 을 추가해서 기능 확장 가능
- 변경에 닫혀 있다 : 기존 코드의 `수정 없이` 동작 추가/변경 가능
- OCP 원칙은 런타임, 컴파일타임 의존성에 관한 이야기임
    - 의존성 관점에서 OCP 원칙을 따르는 설계란, **컴파일타임 의존성은 유지 / 런타임 의존성의 가능성 확장 + 수정할 수 있는 구조**
- OCP 의 핵심은 `추상화` 에 의존하는 것
    - 문맥이 바뀌더라도 **변하지 않는 부분** (추상화된 부분)
        - 남아있는 부분은 **수정에 대해 닫혀있음**
    - 문맥에 따라 **변하는 부분** (추상화 되지 않고 **생략된 부분**)
        - 생략된 부분은 **확장의 여지를 남김**
- 어떤 개념을 추상화했다고 해서, 수정에 닫힌 설계를 만들 수 있는 것은 아님
- **변하는 것과 변하지 않는 것이 무엇인지 이해하고 신중하게 결정하여 추상화하라**

### 생성 사용 분리

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = new AmountDiscountPolicy(...); // movie 가 인스턴스 생성 (CREATE) 
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening)); // movie 가 discountPolicy 객체에게 메시지 전송 (USE)
    }
}
```

- 동일한 클래스 내에서 객체 생성 / 사용이라는 2가지 목적을 가진 코드가 공존하는 것은 문제가 됨
    - 객체와 관련된 2가지 책임을 서로 다른 객체로 분리해야 함 → `생성과 사용을 분리` 하자
- 객체를 생성할 책임을 클라이언트로 옮겨서, Movie 가 특정 클라이언트에 결합되지 않고 독립적이게 하자

```java
public class Client {
    public Money getAvatarFee() {
        Movie avatar = new Movie("아바타",
                Duration.ofMinutes(120),
                Money.wons(10000),
                new AmountDiscountPolicy(
                    Money.wons(800),
                    new SequenceCondition(1),
                    new SequenceCondition(10)));
        return avatar.getFee();
    }
}

public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

- Movie 는 오직 DiscountPolicy 인스턴스를 사용하는 것에만 집중, 구체적인 컨텍스트와 관련된 정보 (AmountDiscountPolicy) 는 Client 에 있음
- Movie 객체 생성 책임을 Client 로 옮기게 되면, Client 또한 특정 컨텍스트에 묶이게 됨
    - 객체 생성과 관련된 책임만 전담하는 별도 객체를 추가하여 Client 가 이 객체를 사용하도록 함
    - `FACTORY` : 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체

```java
public class Factory { // 객체 생성을 전담으로 하는 클래스
    public Movie createAvatarMovie() {
        return new Movie("아바타", // CREATE
                Duration.ofMinutes(120),
                Money.wons(10000),
                new AmountDiscountPolicy(
                    Money.wons(800),
                    new SequenceCondition(1),
                    new SequenceCondition(10)));
    }
}

public class Client {
    private Factory factory;

    public Client(Factory factory) {
        this.factory = factory;
    }

    public Money getAvatarFee() {
        Movie avatar = factory.createAvatarMovie(); // USE
        return avatar.getFee();
    }
}
```

- Factory 를 사용하여 생성과 관련된 책임을 Factory 가 모두 처리하도록 함
- Client 는 오직 `사용` 과 관련된 책임만 지고, 생성과 관련된 어떤 지식도 갖지 않도록 함

### 순수한 가공물에게 책임 할당하기

- 책임 할당의 기본 원칙 : `정보전문가` 에게 책임 할당하기
    - 도메인 모델 안의 개념 중 적절한 후보가 있는지 찾는 것이 우선
- 표현적 분해 : 도메인에 존재하는 `사물 또는 개념을 표현하는 객체` 를 이용해 시스템 분해
    - 도메인과 SW 사이의 표현적 차이를 최소화하는 것을 목적으로 함
- 행위적 분해 : 설계자가 편의를 위해 `도메인과 무관한 인공적인 객체` 를 이용해 시스템 분해
    - 어떤 행동을 추가하려고 할 때, 이 **행동을 책임질 마땅한 도메인 개념이 없다면 PURE FABRICATION (순수한 가공물) 을 추가하고 이 객체에게 책임 할당하라**
- 도메인 개념을 표현하지 않는, 인위적인 클래스에 **매우 응집된 책임을 할당하라**
    - PURE FABRICATION 은 정보 전문가 패턴에 따라 책임할당한 결과가 바람직하지 않은 경우 대안으로 사용됨 <br>
        → 모든 책임을 도메인 객체에 할당해서 낮은 응집도 / 높은 결합도 / 재사용성 저하 같은 문제가 발생할 경우를 의미함

### 의존성 주입

- `의존성 주입` : 사용하는 객체가 아닌 외부의 `독립적인 객체` 가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
    - 의존성을 해결하기 위해, 객체의 `퍼블릭 인터페이스` 에 명시적으로 드러내서, 외부에서 필요한 `런타임 의존성` 을 전달할 수 있도록 만드는 방법
    - 생성자 주입 / setter 주입 / 메소드 주입
        - 생성자 주입 : 객체가 올바른 상태로 생성되는 데 **필요한 의존성을 명확하게 표현 가능**
        - setter 주입 : 의존성의 대상을 런타임에 변경할 수 있다 / 하지만 객체가 올바로 생성되기 위해 **어떤 의존성이 필수적인지 명시적으로 표현 X**
        - 메소드 주입 : 메소드가 의존성을 필요로 하는 유일한 경우일 때 사용
- 의존성 주입 외에 의존성 해결가능한 대표적인 방법 : **SERVICE LOCATOR**
    - 의존성을 해결할 객체들을 보관하는 일종의 저장소
        
        ```java
        public class ServiceLocator {
            private static ServiceLocator soleInstance = new ServiceLocator();
            private DiscountPolicy discountPolicy;
        
            public static DiscountPolicy discountPolicy() { // discountPolicy 객체를 반환할 수 있는 메소드 구현
                return soleInstance.discountPolicy;
            }
        
            public static void provide(DiscountPolicy discountPolicy) { // discountPolicy 객체를 등록할 수 있는 메소드 구현
                soleInstance.discountPolicy = discountPolicy;
            }
        
            private ServiceLocator() {
            }
        }
        ```
        
        ```java
        public class Movie {
            private DiscountPolicy discountPolicy;
        
            public Movie(String title, Duration runningTime, Money fee) {
                this.title = title;
                this.runningTime = runningTime;
                this.fee = fee;
                this.discountPolicy = ServiceLocator.discountPolicy();
            }
        }
        ```
        
    - Movie 의 인스턴스가 AmountDiscountPolicy 에 의존하려면 아래와 같은 코드가 필요
        
        ```java
        ServiceLocator.provide(new AmountDiscountPolicy(...));
        Movie avatar = new Movie("아바타", ...);
        ```
        
    - SERVICE LOCATOR 패턴의 가장 큰 단점 : 의존성을 숨김
        - Movie 의 퍼블릭 인터페이스 어디에도 의존성에 대한 정보 표시 X
        - 의존성을 구현 내부로 감추면 의존성 관련 문제가 컴파일 타임이 아닌 런타임에야 확인되어 디버깅 하기 어려움
