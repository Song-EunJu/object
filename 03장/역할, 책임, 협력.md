## 3장 : 역할, 책임, 협력

- **협력** : 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
    ex) 손님은 커피를 주문하고, 바리스타는 손님이 주문한 커피를 만든다.
    
- **책임** : 협력에 참여하기 위해 수행하는 로직
    ex) 손님은 메뉴를 주문한다 
    
- **역할 :** 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성

### 협력

- 객체지향 세계에서 기능을 구현할 수 있는 유일한 방법
- 객체 사이의 협력은, 하나의 객체가 다른 객체에게 도움을 요청할 때 시작됨
- `메시지 전송` : 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단
    - 메시지 수신 객체는 `메소드` 를 실행해서 요청에 응답
    - 외부의 객체는 **오직 메시지만 전송**하고, 메시지 처리방식은 **메시지 수신 객체가 직접 결정**함
        
        > Screening 클래스에 movie.calculate() 이 있으면, Screening 이 **Movie 의 calculate 메소드를 호출한다**, 라고 말했지만
        사실은 Screening 이 **Movie 에게 calculate 메시지를 전송한다**. 가 적절한 표현
        > 
    - Screening 이 Movie 에게 처리를 위임하는 이유는, 요금 계산을 위한 데이터를 가장 잘 아는 것이 Movie 이기 때문<br>
    → 만약 Screening 이 처리하게 된다면 Movie 의 **내부 구현에 결합되어** Movie 의 **자율성이 훼손**됨
        - 객체의 자율성을 보장하려면, 필요한 정보(데이터) 와 정보에 기반한 행동(메소드) 를 같은 객체 안에 모아두어야 함
        - Movie 가 자율적 존재가 되려면, 자신이 알고 있는 정보를 이용해 직접 요금을 계산해야 함 
        (Screening 과 Movie 사이의 결합도를 느슨하게 유지 가능)
    - 객체를 자율적으로 만드는 가장 기본적인 방법은, `내부 구현의 캡슐화` 임
        - 캡슐화 → 변경에 대한 파급 효과 제한 → 변경에 용이

### 설계를 위한 문맥을 결정하는, 협력

- 객체가 협력에 참여할 수 있는 이유는, **협력에 필요한 적절한 행동을 보유하고 있기 때문**<br>
    → 객체의 행동을 결정하는 것 == 객체가 참여하고 있는 협력
- Movie 객체가 play() - 상영 이라는 행동을 수행해야 할 것 같지만, [영화를 예매하기 위한 협력] 에 참여하고 있기에, Movie 에는 요금을 계산하는 행동과 관련된 메소드들만 존재함
    - Movie 의 행동을 결정하는 것 == 영화 예매를 위한 협력
    - **협력이라는 문맥을 고려하지 않고 Movie 의 행동 결정하는 것은 의미가 없다**
- 객체의 상태는 그 객체가 **`행동을 수행하는데 필요한 정보가 무엇인지`** 로 결정됨<br>
    ex) Movie 가 요금계산을 하기 위해 필요한 fee, DiscountPolicy 인스턴스 변수를 상태의 일부로 가짐
- `상태` : 객체가 행동하는 데 필요한 정보에 의해 결정
- `행동` : 협력 안에서 객체가 처리할 메시지로 결정
    - 협력은 객체를 설계하는 데 필요한 일종의 `문맥` 제공

### 책임

- 책임 == 행위의 집합 == 정보 (내부의 속성, 상태) + 행동 (인터페이스, 메시지)
- 책임이 외부의 `인터페이스` (메시지) 와 내부의 `속성`을 결정한다
    - Movie 는 <영화예매> 라는 협력 안에서 <가격 계산>할 책임이 있으니까, calculateMovieFee <메시지를 수신>할 수 있고, dicountPolicy 랑 fee 를 <속성으로 가진다>
- 협력은 **객체에게 할당할 `책임`을 결정할 수 있는 문맥 제공 →** 객체에게 얼마나 적절한 책임을 할당하느냐가 중요
- 책임을 수행하는데 가장 많은 정보를 갖고, 알고 있는 정보 전문가에게 책임을 할당 → 자율적인 객체를 만들 수 있음

> 협력이 <책임> 을 결정할 수 있는 문맥을 제공하며, 객체가 <책임을 수행하게> 하려면, <메시지 전송> 이 필요하고, 메시지 전송을 하려면 <메시지 정의> 가 선행되어야 함
> 정의된 메시지가 메시지를 수신한 <객체의 책임> 이 되는 것
> 

### 메시지가 객체를 결정한다

- `인터페이스` 는 객체가 이해할 수 있는 메시지 목록이므로, 메시지가 식별될 때까지 객체의 `퍼블릭 인터페이스` 에는 추가되는 것이 없음 → **최소한의 크기 유지 가능**
- 메시지는 외부 객체가 요청하는 무언가를 표현함 → 어떻게 수행하느냐가 아니라 **무엇을 수행하느냐에 초점 맞출 수 있음**

### 행동이 상태를 결정한다

- 상태는 객체가 행동을 수행하기 위해 필요한 재료일 뿐
- 협력 (영화 예매) 이 객체 (영화) 의 행동 (가격 계산) 을 결정하고, 행동 (가격 계산) 이 상태 (가격, 할인정책) 을 결정한다
    - 행동 (가격 계산) 이 객체 (영화) 의 책임이 된다

### 역할

- 협력 안에서 수행하는 `책임의 집합` 이 역할
    - 지금까지 이해한 바로는 책임을 수행하는 애들이 객체였음.
    하지만 사실상 책임의 수행자가 객체라기 보단 실제로는 **익명의 역할**을 먼저 찾고, **역할을 수행할 객체로 특정 인스턴스를 선택**하는 것
- <영화 예매> 협력에서 <할인 요금을 계산할> 책임은 <AmountDiscountPolicy / PercentDiscountPolicy> 객체들에게 있었음
    - AmountDiscountPolicy : `금액 정책으로` 할인 요금 계산할 책임을 가지는 객체
    - PercentDiscountPolicy : `비율 정책으로` 할인 요금 계산할 책임을 가지는 객체<br>
    → 객체가 다르다고 다른 협력으로 구성하면, 협력이 2개일 뿐더러 코드의 중복이 발생함
    - 따라서 두 개의 객체를 포괄하는 <`할인 정책으로` 할인 요금 계산할 책임을 가지는> DiscountPolicy 라는 `역할` 을 기반으로 2개의 협력을 하나로 통합 가능<br>
        → 역할은 구체적인 객체들을 포괄하는 **추상화**<br>
- 역할을 구현하는 일반적인 방법 : 추상클래스 / 인터페이스
- 동일한 책임 을 수행할 수 있는 객체 들을 협력 안에서 수용할 수 있는 역할 을 추상클래스 / 인터페이스로 구현할 수 있다.
    - 동일한 <할인 요금 계산> 을 수행할 수 있는 <AmountDiscountPolicy / PercentDiscountPolicy> 들을 <영화예매> 협력 안에서 수용할 수 있는 < DiscountPolicy>

### 객체와 역할과의 관계

- 협력에 적합한 책임을 수행하는 대상이 한 종류라면, 간단히 객체로 간주하고 여러 종류라면, 역할이라고 부르자
- 설계 초반의 목표는 협력을 위해 `어떤 책임이 필요한지` 를 찾는 것이 가장 중요
    - 우선은 단순하게 객체로 시작, 다양한 객체가 참여하는 것이 확실하면 역할로 시작
    - 협력을 `구체적` 인 객체가 아니라 `추상적` 인 역할의 관점에서 설계하면 유연하고 재사용 가능한 설계가 가능해짐

### 역할과 추상화

- 역할은 `공통의 책임` 을 바탕으로, 객체의 종류를 숨기기 때문에 역할을 객체의 추상화라고 볼 수 있음
- 추상화의 장점
    - 세부사항에 억눌리지 않고, 상위 수준 정책을 쉽고 간단하게 표현 가능
    - **협력 안에서 `동일한 책임`을 수행하는 객체들은 `동일한 역할`을 수행하므로, 대체가능**하여 다양한 객체들을 수용할 수 있게 해주니까 협력이 유연해짐
- 역할 : 객체가 협력에 참여하는 동안에만 존재하는 일시적인 개념, 시스템의 문맥 안에서 무엇을 하는지에 의해서만 정의될 수 있음
    - 객체는 여러 역할을 가질 수 있지만, 특정 협력 내에서는 오직 하나의 역할만이 보여짐
<br>

## 이 장에서 얻은 것
- 협력이라는 문맥을 고려하여 객체의 행동을 결정해야 한다 / 협력이 존재하기에 객체가 존재한다
- 협력은 객체를 설계하는 데 필요한 일종의 `문맥` 을 제공한다
- **협력이라는 문맥을 고려하지 않고 객체의 행동 결정하는 것은 의미가 없다**
- 동일한 `책임` 을 수행할 수 있는 `객체` 들을 `협력` 안에서 수용할 수 있는 `역할` 을 추상클래스 / 인터페이스로 구현할 수 있고, 역할을 객체의 추상화라고 볼 수 있다
