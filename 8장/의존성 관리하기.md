## 8장 : 의존성 관리하기

- 작고 응집도 높은 객체 == 책임의 초점 명확, 한 가지 일만 잘하는 객체
- 객체지향 설계의 핵심은 `협력` 을 위해 `필요한 의존성은 유지` 하면서도, `변경`을 `방해하는 의존성은 제거`

### 의존성 이해하기

- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때, 두 객체 사이에 의존성이 존재하게 됨
- 의존성은 각 시점에 따라 서로 다른 의미를 가짐
    
    ```markdown
    - 의존하는 객체 : PeriodCondition
    - 의존대상 객체(의존되는 객체) : Screening
    ```
    
    - 실행 시점 : 의존하는 객체가 정상 동작하려면, 실행 시에 의존대상 객체가 존재해야 함
        - 어떤 객체가 `예정된` 작업을 정상 수행하기 위해 다른 객체를 필요로 할 경우
    - 구현 시점 : 의존대상 객체가 변경될 경우, 의존하는 객체도 함께 변경됨
        - Screening 이 변경될 때 PeriodCondition 이 영향을 받지만, 그 역은 성립 X 
        → 의존성은 방향성을 가지며, 항상 단방향
- **의존성 : 변경에 의한 영향의 전파 가능성 / 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성**

```java
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
    ... 
    public boolean isSatisfiedBy(Screening screening) {
        return **screening.getStartTime()**.getDayOfWeek().equals(dayOfWeek) &&
                **startTime.compareTo**(screening.getStartTime().toLocalTime()) <= 0&&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

- DayOfWeek 인스턴스에게 compareTo 메시지 전송
- Screening 인스턴스에게 getStartTime 메시지 전송
- 즉, PeriodCondition 이 가질 수 있는 의존성은 총 4가지
    - DayOfWeek, LocalTime 은 인스턴스 변수로서 의존성을 갖게 됨
    - Screening 은 메소드 인자로서 의존성을 갖게 됨
    - DiscountCondition 은 부모 클래스로서 의존성을 갖게 됨 → 퍼블릭 인터페이스

### 의존성 전이
- 직접 의존성 : 한 요소가 다른 요소에 직접 의존하는 경우
    - PeriodCondition 이 Screening 에 의존하는 경우
- 간접 의존성 : 직접 관계는 존재하지 않지만, 의존성 전이에 의해 영향이 전파되는 경우
    - PeriodCondition이 Screening 에 의존하는데, Screening 이 의존하는 대상에 대해서 PeriodCondition 에게 의존성이 전파되는 경우
- 의존성 전이 여부는 변경 방향, 캡슐화 정도에 따라 달라짐

### 런타임 의존성과 컴파일타임 의존성
- 런타임 : 애플리케이션이 실행되는 시점
    - 런타임 의존성이 다루는 주제 == **객체** 사이의 의존성
- 컴파일타임 : 작성된 코드를 컴파일하는 시점,
    - 문맥에 따라서는 코드 그 자체 → 이 용어가 중요하게 생각하는 것은 `시간` 이 아니라 작성한 `코드의 구조` 이기 때문
    - 컴파일타임 의존성이 다루는 주제 == **클래스** 사이의 의존성
- 동일한 소스코드 구조를 가지고, 다양한 실행구조를 만들 수 있어야 함
    - 추상클래스에 의존하게 하고, 이 `컴파일타임 의존성`을 실행시에 객체에 대한 `런타임 의존성`으로 대체해야 함
    - 어떤 클래스의 인스턴스가 다양한 클래스 인스턴스와 협력하려면, **협력할 인스턴스의 구체적인 클래스를 알아서는 안됨**
        - 실제 협력할 객체는 런타임에 해결해야 함
    - 컴파일타임 구조와 런타임구조 사이의 **거리가 멀면 멀수록** 설계가 유연하고 재사용 가능해짐

### 컨텍스트 독립성
- 클래스가 사용될 특정한 문맥에 대해 `최소한의 가정` 만으로 이루어지면, 다른 문맥에서 `재사용`하기가 더 수월함
    - 협력할 객체의 구체클래스에 대해 알면, 특정 문맥에 강하게 결합되기 때문에 최소한으로만 가정.

### 의존성 해결하기

- 의존성 해결 : 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체
    - 객체 생성 시점에 `생성자` 로 해결
    - 객체 생성 후 `setter` 로 해결
        - 객체 생성 이후, 의존하고 있는 대상을 **변경 가능성을 열어두고 싶은 경우**
        - 객체 생성 후에 의존 대상을 설정하기 때문에, 객체 생성 후 의존 대상을 설정하기 전까지는 객체 **상태가 불완전할 수 있음**
    
    → 따라서 객체 생성시 완전한 객체 생성 후, 필요에 따라 setter 메소드를 이용해 의존대상 변경
    
    - `메소드 실행 시 인자` 이용
        - 협력 대상에 대해 지속적으로 의존 관계 맺을 필요 없이, 메소드 실행하는 동안만 `일시적` 으로 의존 관계 존재해도 될 때
        - 메소드 실행될 때마다 의존대상이 매번 달라지는 경우
