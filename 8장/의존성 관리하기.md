## 8장 : 의존성 관리하기

- 작고 응집도 높은 객체 == 책임의 초점 명확, 한 가지 일만 잘하는 객체
- 객체지향 설계의 핵심은 `협력` 을 위해 `필요한 의존성은 유지` 하면서도, `변경`을 `방해하는 의존성은 제거`

### 의존성 이해하기

- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때, 두 객체 사이에 의존성이 존재하게 됨
- 의존성은 각 시점에 따라 서로 다른 의미를 가짐
    
    ```markdown
    - 의존하는 객체 : PeriodCondition
    - 의존대상 객체(의존되는 객체) : Screening
    ```
    
    - 실행 시점 : 의존하는 객체가 정상 동작하려면, 실행 시에 의존대상 객체가 존재해야 함
        - 어떤 객체가 `예정된` 작업을 정상 수행하기 위해 다른 객체를 필요로 할 경우
    - 구현 시점 : 의존대상 객체가 변경될 경우, 의존하는 객체도 함께 변경됨
        - Screening 이 변경될 때 PeriodCondition 이 영향을 받지만, 그 역은 성립 X 
        → 의존성은 방향성을 가지며, 항상 단방향
- **의존성 : 변경에 의한 영향의 전파 가능성 / 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성**

```java
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
    ... 
    public boolean isSatisfiedBy(Screening screening) {
        return **screening.getStartTime()**.getDayOfWeek().equals(dayOfWeek) &&
                **startTime.compareTo**(screening.getStartTime().toLocalTime()) <= 0&&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

- DayOfWeek 인스턴스에게 compareTo 메시지 전송
- Screening 인스턴스에게 getStartTime 메시지 전송
- 즉, PeriodCondition 이 가질 수 있는 의존성은 총 4가지
    - DayOfWeek, LocalTime 은 인스턴스 변수로서 의존성을 갖게 됨
    - Screening 은 메소드 인자로서 의존성을 갖게 됨
    - DiscountCondition 은 부모 클래스로서 의존성을 갖게 됨 → 퍼블릭 인터페이스

### 의존성 전이
- 직접 의존성 : 한 요소가 다른 요소에 직접 의존하는 경우
    - PeriodCondition 이 Screening 에 의존하는 경우
- 간접 의존성 : 직접 관계는 존재하지 않지만, 의존성 전이에 의해 영향이 전파되는 경우
    - PeriodCondition이 Screening 에 의존하는데, Screening 이 의존하는 대상에 대해서 PeriodCondition 에게 의존성이 전파되는 경우
- 의존성 전이 여부는 변경 방향, 캡슐화 정도에 따라 달라짐

### 런타임 의존성과 컴파일타임 의존성
- 런타임 : 애플리케이션이 실행되는 시점
    - 런타임 의존성이 다루는 주제 == **객체** 사이의 의존성
- 컴파일타임 : 작성된 코드를 컴파일하는 시점,
    - 문맥에 따라서는 코드 그 자체 → 이 용어가 중요하게 생각하는 것은 `시간` 이 아니라 작성한 `코드의 구조` 이기 때문
    - 컴파일타임 의존성이 다루는 주제 == **클래스** 사이의 의존성
- 동일한 소스코드 구조를 가지고, 다양한 실행구조를 만들 수 있어야 함
    - 추상클래스에 의존하게 하고, 이 `컴파일타임 의존성`을 실행시에 객체에 대한 `런타임 의존성`으로 대체해야 함
    - 어떤 클래스의 인스턴스가 다양한 클래스 인스턴스와 협력하려면, **협력할 인스턴스의 구체적인 클래스를 알아서는 안됨**
        - 실제 협력할 객체는 런타임에 해결해야 함
    - 컴파일타임 구조와 런타임구조 사이의 **거리가 멀면 멀수록** 설계가 유연하고 재사용 가능해짐

### 컨텍스트 독립성
- 클래스가 사용될 특정한 문맥에 대해 `최소한의 가정` 만으로 이루어지면, 다른 문맥에서 `재사용`하기가 더 수월함
    - 협력할 객체의 구체클래스에 대해 알면, 특정 문맥에 강하게 결합되기 때문에 최소한으로만 가정.

### 의존성 해결하기

- 의존성 해결 : 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체
    - 객체 생성 시점에 `생성자` 로 해결
    - 객체 생성 후 `setter` 로 해결
        - 객체 생성 이후, 의존하고 있는 대상을 **변경 가능성을 열어두고 싶은 경우**
        - 객체 생성 후에 의존 대상을 설정하기 때문에, 객체 생성 후 의존 대상을 설정하기 전까지는 객체 **상태가 불완전할 수 있음**
    
    → 따라서 객체 생성시 완전한 객체 생성 후, 필요에 따라 setter 메소드를 이용해 의존대상 변경
    
    - `메소드 실행 시 인자` 이용
        - 협력 대상에 대해 지속적으로 의존 관계 맺을 필요 없이, 메소드 실행하는 동안만 `일시적` 으로 의존 관계 존재해도 될 때
        - 메소드 실행될 때마다 의존대상이 매번 달라지는 경우

### 의존성과 결합도

- **의존성** : 객체들의 협력을 가능하게 만드는 매개체이므로, 모든 의존성이 나쁜 것은 아님.
- 바람직한 의존성
    - 다양한 환경에서 클래스를 `재사용`할 수 있는 경우
    - 특정 컨텍스트에 `독립적`인 의존성<br>
    → 두 요소 사이에 존재하는 의존성이 바람직할 때, **느슨한 결합도** 
- 바람직하지 않은 의존성
    - 다른 환경에서 재사용하기 위해 `내부 구현을 변경`하게 만드는 의존성<br>
    → 두 요소 사이의 의존성이 바람직하지 않을 때, **강한 결합도**
- **의존성과 결합도는 동의어가 아님!**
    - 의존성 : 두 요소 사이의 **관계 유무**
        - 의존성 존재한다 / 존재하지 않는다
    - 결합도 : 두 요소 사이에 존재하는 **의존성의 정도**
        - 결합도가 강하다 / 느슨하다
- 결합도의 정도 : 한 요소가 자신이 의존하는 다른 요소에 대해 `알고 있는 정보의 양`으로 결정됨
    - 더 많이 알수록 (더 적은 컨텍스트에서 재사용 가능) 더 많이 결합됨
    - 결합도를 느슨하게 하려면 협력 대상에 대해 **필요한 정보 외에는 최대한 감추자** → 추상화를 통해!
<br>

> **결합도가 강하다 == 바람직하지 않은 의존성을 갖는다 == 많은 정보를 알고 있다 <br>
결합도가 느슨하다 == 바람직한 의존성을 갖는다 == 구체적인 정보에 대해서 알지 못한다**
>

### 추상화에 의존하라
- 추상화를 사용하면 현재 다루는 문제를 해결하는데 불필요한 정보를 감출 수 있다
- 결합도가 가장 느슨해지는 순서 : `구체 클래스` 의존 > `추상 클래스` 의존 > `인터페이스` 의존
    - 추상클래스 : 메소드 내부 구현 + 자식 클래스 종류를 숨길 수 있음
        - 하지만 협력하는 대상이 속한 클래스 상속 계층에 대해 알고 있어야 함
    - 인터페이스 : 협력하는 객체가 어떤 메시지를 수신하는지만 알려줌
        - 다양한 클래스 상속 계층에 속한 객체들이 `동일 메시지` 를 수신하도록 컨텍스트 확장하는 것을 가능케함
- **의존하는 대상이 더 추상적일수록, 결합도는 낮아진다**

### 명시적인 의존성

```java
public class Movie {
    private DiscountPolicy discountPolicy;
    public Movie(String title, Duration runningTime, Money fee) {
        this.discountPolicy = new AmountDiscountPolicy(...); // 구체클래스에 의존하고 있음
    }
}
```

- 인스턴스 변수 타입만 추상클래스/인터페이스로 선언하는 것은 부족함.
구체 클래스에 대한 모든 의존성을 제거해야 함

```java
public class Movie {
    private DiscountPolicy discountPolicy;
    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) { // 퍼블릭 인터페이스에 Movie 가 DiscountPolicy 에 의존함을 명시적으로 드러내고 있음 : 명시적인 의존성
        this.discountPolicy = new discountPolicy;
    }
}
```

- 인스턴스 변수 타입, 생성자의 인자타입 모두 추상클래스로 선언함.
객체 생성 시 DiscountPolicy 의 자식 클래스 중 어떤 것이라도 전달 가능
- 의존성 대상을 생성자의 인자로 전달하기 == 의존성을 명시적으로 `퍼블릭 인터페이스`에 노출하기 : `명시적인 의존성`
    - 생성자 인자로 선언 / setter 메소드 / 메소드 인자 방식 모두 해당됨
- 의존성 대상을 생성자 안에서 직접 생성하기 == 의존성이 퍼블릭 인터페이스에 표현되지 않는 경우 : `숨겨진 의존성`
- 의존성이 명시적이지 않으면 의존성 파악을 위해 내부 구현을 뒤져봐야 함
    - 즉, 해당 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 변경해야 함

> **퍼블릭 인터페이스를 통해 의존성을 명시적으로 표현하여, 컴파일타임 의존성을 적절한 런타임 의존성으로 교체하라!**
의존성을 감추는 것을 경계하라
>

### new는 해롭다
- new 를 사용하려면 구체클래스의 이름을 직접 기술해야 하므로, 추상화가 아니라 구체 클래스에 의존할 수 밖에 없어져 결합도 상승
