## 6장 : 메시지와 인터페이스

- 책임 : 객체가 수신할 수 있는 메시지의 기반이 됨
- 객체가 수신하는 메시지가 객체의 `퍼블릭 인터페이스` 를 구성

### 협력과 메시지

- 두 객체 사이의 협력 관계를 설명하기 위해 사용되는 것 `클라이언트-서버 모델`
    - 클라이언트 : 메시지 전송 객체
    - 서버 : 메시지 수신 객체
- **`시그니처`** = 오퍼레이션명 + 파라미터 목록
- **`메시지`** = **오퍼레이션명** + **인자 (argument)**
    - **isSatisfiedBy**(**screening**)
- **`메시지 전송` = 오퍼레이션명 + 인자 + 수신자**
    - **condition**.**isSatisfiedBy**(**screening**);
- **`메소드`** = 메시지 수신 시 **실제 실행되는 함수** 또는 프로시저
    - condition > PeriodCondition / SequenceCondition 이기에, 클래스의 종류마다 실제 실행되는 코드가 달라짐
    - 메시지 전송 시에는 어떤 코드 실행될지 **정확히 알지 못하고**, 실행 시점에 **메시지를 수신하는 객체의 타입에 따라** 실행되는 코드가 달라짐
    - 메시지와 메소드의 구분 : 메시지 전송자, 수신자의 느슨한 결합을 유도
    - 오퍼레이션에 대한 구현
- **`퍼블릭 인터페이스`** = 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합, 클래스의 퍼블릭 메소드들
- **`오퍼레이션`** = 퍼블릭 인터페이스에 포함된 메시지 (메소드에 대한 추상화)
    - 메시지와 관련된 **시그니처를 가리키는 경우**가 대부분  ex) isSatisfiedBy
    - isSatisfiedBy 를 실제 구현하는 PeriodCondition / SequenceCondition 의 **메소드**들은 isSatisfiedBy **오퍼레이션의 구현**들임
        - 오퍼레이션 / 메소드의 구분은 `다형성` 의 개념과 연결됨
<br>

- 객체가 다른 객체에게 메시지 전송 = 런타임은 `메시지 전송` 을 `오퍼레이션` 호출로 해석
- 메시지 수신한 객체의 **실제타입**을 기반으로, `메소드` 를 찾아 실행


### 인터페이스와 설계 품질

- 좋은 인터페이스 
= **최소한**의 인터페이스 ( 꼭 필요한 오퍼레이션만 포함 ) + **추상적**인 인터페이스 (  어떻게가 아니라, 무엇을 하는지 표현 )
- `디미터 법칙` : 객체의 내부 구조에 강하게 결합되지 않도록, **협력 경로 (접근해야 하는 요소) 를 제한하라** !
    - 오직 하나의 도트만 사용하라 ! 객체.객체.객체처럼 타고타고 접근하지 마라
    - 클래스가 아래의 대상에게만 메시지 전송하도록 코드 작성하자
    
    ```java
    * 클래스 C / C에 구현된 메소드 M 에 대해서
    this 객체 (C 자체)
    메소드의 매개변수 (M의 인자로 전달된 클래스)
    this 의 속성 (C의 인스턴스 변수의 클래스)
    this 의 속성인 컬렉션 요소 
    메소드 내에서 생성된 지역 객체 (M에 의해 생성된 객체)
    ```
    
    - screening.getMovie().getDiscountConditions() → 디미터 법칙 위반한 것
        - 이는 `기차 충돌` 이라 부르며, 클래스 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태
