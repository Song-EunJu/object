## 6장 : 메시지와 인터페이스

- 책임 : 객체가 수신할 수 있는 메시지의 기반이 됨
- 객체가 수신하는 메시지가 객체의 `퍼블릭 인터페이스` 를 구성

### 협력과 메시지

- 두 객체 사이의 협력 관계를 설명하기 위해 사용되는 것 `클라이언트-서버 모델`
    - 클라이언트 : 메시지 전송 객체
    - 서버 : 메시지 수신 객체
- **`시그니처`** = 오퍼레이션명 + 파라미터 목록
- **`메시지`** = **오퍼레이션명** + **인자 (argument)**
    - **isSatisfiedBy**(**screening**)
- **`메시지 전송` = 오퍼레이션명 + 인자 + 수신자**
    - **condition**.**isSatisfiedBy**(**screening**);
- **`메소드`** = 메시지 수신 시 **실제 실행되는 함수** 또는 프로시저
    - condition > PeriodCondition / SequenceCondition 이기에, 클래스의 종류마다 실제 실행되는 코드가 달라짐
    - 메시지 전송 시에는 어떤 코드 실행될지 **정확히 알지 못하고**, 실행 시점에 **메시지를 수신하는 객체의 타입에 따라** 실행되는 코드가 달라짐
    - 메시지와 메소드의 구분 : 메시지 전송자, 수신자의 느슨한 결합을 유도
    - 오퍼레이션에 대한 구현
- **`퍼블릭 인터페이스`** = 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합, 클래스의 퍼블릭 메소드들
- **`오퍼레이션`** = 퍼블릭 인터페이스에 포함된 메시지 (메소드에 대한 추상화)
    - 메시지와 관련된 **시그니처를 가리키는 경우**가 대부분  ex) isSatisfiedBy
    - isSatisfiedBy 를 실제 구현하는 PeriodCondition / SequenceCondition 의 **메소드**들은 isSatisfiedBy **오퍼레이션의 구현**들임
        - 오퍼레이션 / 메소드의 구분은 `다형성` 의 개념과 연결됨
<br>

- 객체가 다른 객체에게 메시지 전송 = 런타임은 `메시지 전송` 을 `오퍼레이션` 호출로 해석
- 메시지 수신한 객체의 **실제타입**을 기반으로, `메소드` 를 찾아 실행


### 인터페이스와 설계 품질

- 좋은 인터페이스 
= **최소한**의 인터페이스 ( 꼭 필요한 오퍼레이션만 포함 ) + **추상적**인 인터페이스 (  어떻게가 아니라, 무엇을 하는지 표현 )
- `디미터 법칙` : 객체의 내부 구조에 강하게 결합되지 않도록, **협력 경로 (접근해야 하는 요소) 를 제한하라** !
    - 오직 하나의 도트만 사용하라 ! 객체.객체.객체처럼 타고타고 접근하지 마라
    - 클래스가 아래의 대상에게만 메시지 전송하도록 코드 작성하자
    
    ```java
    * 클래스 C / C에 구현된 메소드 M 에 대해서
    this 객체 (C 자체)
    메소드의 매개변수 (M의 인자로 전달된 클래스)
    this 의 속성 (C의 인스턴스 변수의 클래스)
    this 의 속성인 컬렉션 요소 
    메소드 내에서 생성된 지역 객체 (M에 의해 생성된 객체)
    ```
    
    - screening.getMovie().getDiscountConditions() → 디미터 법칙 위반한 것
        - 이는 `기차 충돌` 이라 부르며, 클래스 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태
     
### 묻지말고 시켜라

- **객체의 상태에 관해 묻지말고 원하는 것을 시키는** 메시지를 작성하라
    - 객체 외부에서 객체 상태를 기반으로 결정을 내리는 것 → 캡슐화 위반
    - 구현 로직은 메시지 수신자가 담당해야 하는 책임
        - 따라서 메시지 송신자가 수신자에게 “시키는 메시지” 를 보내면, 수신자가 자율적으로 행동해야 하므로, 객체 정보를 이용하는 행동을 객체 내부에 위치시키게 되기 때문에 정보 + 행동이 동일 클래스에 위치하게 됨
- 체크해야 할 사항
    - 내부 상태를 묻는 오퍼레이션을 인터페이스에 포함하고 있는가
    - 내부 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가
    
    → `상태 묻는` 오퍼레이션을 `행동 요청` 하는 오퍼레이션으로 대체
    

### 의도를 드러내는 인터페이스를 설계하자

- 메소드가 작업을 `어떻게` 수행하는 지 드러내는 메소드 이름은, 내부의 구현 방법을 드러냄 → 메소드 수준에서 캡슐화 위반하는 것
- 클라이언트 관점에서 Period / SequenceCondition 모두 “할인 여부를 판단”하는 것이 중요하므로, isSatisfiedByPeriod / Sequence 가 아니라 isSatisfiedBy 라는 같은 이름의 메소드 사용
    - `동일한 목적` 을 가진다는 것을 메소드 이름을 통해 명확하게 표현하자
    - 메소드가 무슨 작업을 하느냐에 초점을 맞추면, **동일한 작업을 수행하는 메소드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커짐**
- 메시지는, **수신객체가 아니라 전송객체 (클라이언트) 의 의도를 반영**해서 결정해야 함 = **클라이언트가 객체에게 무엇을 원하는지 명확히 표현하기**
    - Theater 는 TicketSeller 에게 “티켓을 판매하라” 를 원함. → sellTo()
    - TicketSeller 는 Audience 에게 “티켓을 구매하라” 를 원함 → buy()
    - Audience 는 Bag 에게 “티켓을 보관하라” 를 원함 → hold()


### 원칙의 함정

- 설계를 적절하게 트레이드오프 할 수 있는 능력이 고수와 하수를 구분하는 기준
- 적용하려는 원칙이 현 상황에 부적합하다고 판단되면, 과감하게 원칙을 무시하라 ! → 중요한 것은, 원칙이 유용한 시점을 판단하는 능력을 기르는 것

1. 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다

```java
IntStream.of(1, 15, 2).filter(x -> x>10).distint().count();
```

- 위 경우에는 모두 IntStream 이라는 동일한 클래스의 인스턴스를 반환하고 있음
- 디미터 법칙은 `결합도` 와 관련된 것으로, **객체 내부 구현에 대한 정보가 외부로 노출되는 경우**에만 문제가 됨.
- 따라서 객체 내부에 대한 내용을 묻지 않고, 객체를 다른 객체로 변환하는 위의 예제에서는 디미터 법칙을 준수한 것
- 디미터 법칙의 위반 여부는, 묻는 대상이 **객체 (내부 구조 숨겨야 함)** 이냐 / **자료구조 (당연히 내부 노출)** 이냐에 달려있음
<br>

- 어떤 객체의 상태를 물어보고, 반환된 상태를 기반으로 결정을 내린다면 `묻지 말고 시켜라` 스타일로 변경해야함
- 어떤 객체의 `캡슐화` 를 향상시키는 것보다, 객체의 `응집도` 를 높이고, 객체간의 `결합도` 를 낮추는 것이 전체적인 관점에서 더 좋은 방법이 될 수 있음

### 명령-쿼리 분리 원칙

- `루틴` : 어떠한 절차를 묶어, 호출 가능하도록, 이름을 부여한 기능 모듈
- `프로시저` : 정해진 절차에 따라, **내부의 상태 변경**하는 루틴의 종류 / 부수 효과 발생 O, 값 반환 X → Command
- `함수` : 정해진 절차에 따라, **필요한 값을 계산해서 반환**하는 루틴의 종류 / 부수 효과 발생 X, 값 반환 O → Query
- 명령과 쿼리를 뒤섞으면 실행 결과가 예측하기 어려워짐. **따라서 하나의 메소드가 하나의 역할만 수행하도록 하자**
    <br>
    → 따라서 메소드가 반환 값을 갖는지 여부만 확인하여 Command/Query 를 구분해내자
    <br>
    → Command/Query 를 분리한 코드는 예측 가능하고, 이해하기 쉬우며, 디버깅 용이하고, 유지보수가 수월함
    
- 명령과 쿼리를 분리함으로써, 명령형 언어 틀에서 `참조 투명성` 의 장점을 제한적이나마 누릴 수 있음
    - 참조 투명성 : 어떤 표현식 e 의 값으로, e가 나타나는 모든 위치를 교체해도 결과가 같음
        - 수학에서 함수는, 동일 입력에 대해 항상 동일한 값 반환 → 참조투명성 만족
        - 불변성 == 부수효과의 발생 방지 == 참조 투명성 만족
        - 컴퓨터 세계 vs 수학 세계 ⇒ 부수효과의 존재 유무가 다름
    - 명령형 프로그래밍 : `부수효과`를 기반으로 하는 프로그래밍 방식
        - 객체지향 프로그래밍 언어도, 메시지에 의한 객체 상태 변경에 집중하므로 이것으로 분류됨
        - 함수형 프로그래밍 : `부수효과가 존재하지 않는` 수학적 함수에 기반
            - 참조 투명성 장점 극대화 가능
            - 명령형에 비해 실행 결과 이해하고 예측하기가 더 쉬움
            - 하드웨어 발달로 병렬처리가 중요해져서 인기 상승
