## 6장 : 메시지와 인터페이스

- 책임 : 객체가 수신할 수 있는 메시지의 기반이 됨
- 객체가 수신하는 메시지가 객체의 `퍼블릭 인터페이스` 를 구성

### 협력과 메시지

- 두 객체 사이의 협력 관계를 설명하기 위해 사용되는 것 `클라이언트-서버 모델`
    - 클라이언트 : 메시지 전송 객체
    - 서버 : 메시지 수신 객체
- **`시그니처`** = 오퍼레이션명 + 파라미터 목록
- **`메시지`** = **오퍼레이션명** + **인자 (argument)**
    - **isSatisfiedBy**(**screening**)
- **`메시지 전송` = 오퍼레이션명 + 인자 + 수신자**
    - **condition**.**isSatisfiedBy**(**screening**);
- **`메소드`** = 메시지 수신 시 **실제 실행되는 함수** 또는 프로시저
    - condition > PeriodCondition / SequenceCondition 이기에, 클래스의 종류마다 실제 실행되는 코드가 달라짐
    - 메시지 전송 시에는 어떤 코드 실행될지 **정확히 알지 못하고**, 실행 시점에 **메시지를 수신하는 객체의 타입에 따라** 실행되는 코드가 달라짐
    - 메시지와 메소드의 구분 : 메시지 전송자, 수신자의 느슨한 결합을 유도
    - 오퍼레이션에 대한 구현
- **`퍼블릭 인터페이스`** = 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합, 클래스의 퍼블릭 메소드들
- **`오퍼레이션`** = 퍼블릭 인터페이스에 포함된 메시지 (메소드에 대한 추상화)
    - 메시지와 관련된 **시그니처를 가리키는 경우**가 대부분  ex) isSatisfiedBy
    - isSatisfiedBy 를 실제 구현하는 PeriodCondition / SequenceCondition 의 **메소드**들은 isSatisfiedBy **오퍼레이션의 구현**들임
        - 오퍼레이션 / 메소드의 구분은 `다형성` 의 개념과 연결됨
<br>

- 객체가 다른 객체에게 메시지 전송 = 런타임은 `메시지 전송` 을 `오퍼레이션` 호출로 해석
- 메시지 수신한 객체의 **실제타입**을 기반으로, `메소드` 를 찾아 실행


### 인터페이스와 설계 품질

- 좋은 인터페이스 
= **최소한**의 인터페이스 ( 꼭 필요한 오퍼레이션만 포함 ) + **추상적**인 인터페이스 (  어떻게가 아니라, 무엇을 하는지 표현 )
- `디미터 법칙` : 객체의 내부 구조에 강하게 결합되지 않도록, **협력 경로 (접근해야 하는 요소) 를 제한하라** !
    - 오직 하나의 도트만 사용하라 ! 객체.객체.객체처럼 타고타고 접근하지 마라
    - 클래스가 아래의 대상에게만 메시지 전송하도록 코드 작성하자
    
    ```java
    * 클래스 C / C에 구현된 메소드 M 에 대해서
    this 객체 (C 자체)
    메소드의 매개변수 (M의 인자로 전달된 클래스)
    this 의 속성 (C의 인스턴스 변수의 클래스)
    this 의 속성인 컬렉션 요소 
    메소드 내에서 생성된 지역 객체 (M에 의해 생성된 객체)
    ```
    
    - screening.getMovie().getDiscountConditions() → 디미터 법칙 위반한 것
        - 이는 `기차 충돌` 이라 부르며, 클래스 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태
     
### 묻지말고 시켜라

- **객체의 상태에 관해 묻지말고 원하는 것을 시키는** 메시지를 작성하라
    - 객체 외부에서 객체 상태를 기반으로 결정을 내리는 것 → 캡슐화 위반
    - 구현 로직은 메시지 수신자가 담당해야 하는 책임
        - 따라서 메시지 송신자가 수신자에게 “시키는 메시지” 를 보내면, 수신자가 자율적으로 행동해야 하므로, 객체 정보를 이용하는 행동을 객체 내부에 위치시키게 되기 때문에 정보 + 행동이 동일 클래스에 위치하게 됨
- 체크해야 할 사항
    - 내부 상태를 묻는 오퍼레이션을 인터페이스에 포함하고 있는가
    - 내부 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가
    
    → `상태 묻는` 오퍼레이션을 `행동 요청` 하는 오퍼레이션으로 대체
    

### 의도를 드러내는 인터페이스를 설계하자

- 메소드가 작업을 `어떻게` 수행하는 지 드러내는 메소드 이름은, 내부의 구현 방법을 드러냄 → 메소드 수준에서 캡슐화 위반하는 것
- 클라이언트 관점에서 Period / SequenceCondition 모두 “할인 여부를 판단”하는 것이 중요하므로, isSatisfiedByPeriod / Sequence 가 아니라 isSatisfiedBy 라는 같은 이름의 메소드 사용
    - `동일한 목적` 을 가진다는 것을 메소드 이름을 통해 명확하게 표현하자
    - 메소드가 무슨 작업을 하느냐에 초점을 맞추면, **동일한 작업을 수행하는 메소드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커짐**
- 메시지는, **수신객체가 아니라 전송객체 (클라이언트) 의 의도를 반영**해서 결정해야 함 = **클라이언트가 객체에게 무엇을 원하는지 명확히 표현하기**
    - Theater 는 TicketSeller 에게 “티켓을 판매하라” 를 원함. → sellTo()
    - TicketSeller 는 Audience 에게 “티켓을 구매하라” 를 원함 → buy()
    - Audience 는 Bag 에게 “티켓을 보관하라” 를 원함 → hold()


### 원칙의 함정

- 설계를 적절하게 트레이드오프 할 수 있는 능력이 고수와 하수를 구분하는 기준
- 적용하려는 원칙이 현 상황에 부적합하다고 판단되면, 과감하게 원칙을 무시하라 ! → 중요한 것은, 원칙이 유용한 시점을 판단하는 능력을 기르는 것

1. 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다

```java
IntStream.of(1, 15, 2).filter(x -> x>10).distint().count();
```

- 위 경우에는 모두 IntStream 이라는 동일한 클래스의 인스턴스를 반환하고 있음
- 디미터 법칙은 `결합도` 와 관련된 것으로, 객체 내부 구현에 대한 정보가 외부로 노출되는 경우에만 문제가 됨.
- 따라서 객체 내부에 대한 내용을 묻지 않고, 객체를 다른 객체로 변환하는 위의 예제에서는 디미터 법칙을 준수한 것
