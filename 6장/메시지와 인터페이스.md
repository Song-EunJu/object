## 6장 : 메시지와 인터페이스

- 책임 : 객체가 수신할 수 있는 메시지의 기반이 됨
- 객체가 수신하는 메시지가 객체의 `퍼블릭 인터페이스` 를 구성

### 협력과 메시지

- 두 객체 사이의 협력 관계를 설명하기 위해 사용되는 것 `클라이언트-서버 모델`
    - 클라이언트 : 메시지 전송 객체
    - 서버 : 메시지 수신 객체
- **`시그니처`** = 오퍼레이션명 + 파라미터 목록
- **`메시지`** = **오퍼레이션명** + **인자 (argument)**
    - **isSatisfiedBy**(**screening**)
- **`메시지 전송` = 오퍼레이션명 + 인자 + 수신자**
    - **condition**.**isSatisfiedBy**(**screening**);
- **`메소드`** = 메시지 수신 시 **실제 실행되는 함수** 또는 프로시저
    - condition > PeriodCondition / SequenceCondition 이기에, 클래스의 종류마다 실제 실행되는 코드가 달라짐
    - 메시지 전송 시에는 어떤 코드 실행될지 **정확히 알지 못하고**, 실행 시점에 **메시지를 수신하는 객체의 타입에 따라** 실행되는 코드가 달라짐
    - 메시지와 메소드의 구분 : 메시지 전송자, 수신자의 느슨한 결합을 유도
    - 오퍼레이션에 대한 구현
- **`퍼블릭 인터페이스`** = 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합, 클래스의 퍼블릭 메소드들
- **`오퍼레이션`** = 퍼블릭 인터페이스에 포함된 메시지 (메소드에 대한 추상화)
    - 메시지와 관련된 **시그니처를 가리키는 경우**가 대부분  ex) isSatisfiedBy
    - isSatisfiedBy 를 실제 구현하는 PeriodCondition / SequenceCondition 의 **메소드**들은 isSatisfiedBy **오퍼레이션의 구현**들임
        - 오퍼레이션 / 메소드의 구분은 `다형성` 의 개념과 연결됨
<br>

- 객체가 다른 객체에게 메시지 전송 = 런타임은 `메시지 전송` 을 `오퍼레이션` 호출로 해석
- 메시지 수신한 객체의 **실제타입**을 기반으로, `메소드` 를 찾아 실행
