## 2장 : 객체지향 프로그래밍

### 객체지향 패러다임으로의 전환 방법

1. 어떤 클래스가 필요한지 고민하기 전에, **어떤 객체들이 어떤 상태와 행동을 가지는 지** 고민하라
    - 클래스는 그저 공통적인 상태+행동을 공유하는 객체들을 추상화한 것일 뿐이다
    - 객체 틀 잡기 → 공통 특성+상태를 가진 객체를 타입으로 분류하기 → 타입을 기반으로 클래스를 구현하기
2. 객체를 협력에 참여하는 협력자로 바라보아라

### 도메인의 구조를 따르는 프로그램 구조

- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 객체지향 패러다임이 강력한 이유 : 요구사항 분석하는 초기 단계 ~ 프로그램 구현하는 마지막 단계까지 `객체` 라는 동일한 추상화 기법을 사용할 수 있다
- **도메인을 구성하는 개념과 관계를 반영하도록 프로그램을 구조화해야 하므로**
    - 클래스의 구조는 도메인의 구조와 유사해야 한다
    - 클래스의 이름은 대응되는 도메인 개념의 이름과 동일/유사해야 한다

- 클래스 구현, 또는 이미 개발된 클래스 사용 시 중요한 것은 `클래스의 경계를 구분 짓는 것`
    - 어떤 부분을 외부에 공개할지, 내부로 감출지 결정하는 것이 핵심
    
    → **경계의 명확성이 객체의 자율성을 보장하기 때문 ! +) 프로그래머에게 구현의 자유 제공**

### 자율적인 객체

- 객체는 상태, 행동을 함께 가지며, 스스로 판단하고 행동하는 자율적인 존재이다
    - `캡슐화`: 데이터와 기능을 객체 내부로 함께 묶는 것
    - 대부분 객체지향 프로그래밍에서는 캡슐화에서 나아가, 외부에서 접근 통제가능한 `접근 제어` 메커니즘도 제공  
        → 객체 내부에 대한 접근을 통제하는 이유 : **객체를** 경계의 명확성을 보장하는 **자율적인 존재로 만들기 위해서**
        - 객체를 자율적인 존재로 만들기 위해서는 외부 간섭을 최소화 해야 함
    - `퍼블릭 인터페이스`  : 외부에서 접근 가능한 부분 (public 메소드)
    - `구현` : 외부에서 접근 불가능 / 내부에서만 접근 가능 (private, protected 메소드, 속성)
        → 일반적으로 객체의 상태는 숨기고, 행동만 외부에 공개해야 함
        

### 프로그래머의 자유

- `클래스 작성자` 는 새로운 데이터 타입을 프로그램에 추가하는 사람
- `클라이언트 프로그래머` 는 클래스 작성자가 추가한 데이터 타입을 사용하는 사람
- 클래스 작성자는, 클라이언트 프로그래머가 숨겨 놓은 부분에 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 내부 구현 마음대로 변경 가능 → `구현 은닉`
- `접근제어` : 클래스 **내부, 외부를 명확하게 경계** 지을 수 있게 함 + 클래스 작성자가 **내부 구현을 은닉**할 수 있게 함
    - 클래스 작성자는 자유롭게 구현부 변경 가능
    - 클라이언트 프로그래머는 내부 구현 무시한 채 인터페이스만으로도 클래스 사용 가능
<br>

## 이 장에서 얻은 것
- 변경된 가능성이 있는 세부 구현을 private 영역 안에 감춤으로써 변경 관리를 손쉽게 할 수 있다.
