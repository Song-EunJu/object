## 2장 : 객체지향 프로그래밍

### 객체지향 패러다임으로의 전환 방법

1. 어떤 클래스가 필요한지 고민하기 전에, **어떤 객체들이 어떤 상태와 행동을 가지는 지** 고민하라
    - 클래스는 그저 공통적인 상태+행동을 공유하는 객체들을 추상화한 것일 뿐이다
    - 객체 틀 잡기 → 공통 특성+상태를 가진 객체를 타입으로 분류하기 → 타입을 기반으로 클래스를 구현하기
2. 객체를 협력에 참여하는 협력자로 바라보아라

### 도메인의 구조를 따르는 프로그램 구조

- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 객체지향 패러다임이 강력한 이유 : 요구사항 분석하는 초기 단계 ~ 프로그램 구현하는 마지막 단계까지 `객체` 라는 동일한 추상화 기법을 사용할 수 있다
- **도메인을 구성하는 개념과 관계를 반영하도록 프로그램을 구조화해야 하므로**
    - 클래스의 구조는 도메인의 구조와 유사해야 한다
    - 클래스의 이름은 대응되는 도메인 개념의 이름과 동일/유사해야 한다
- 클래스 구현, 또는 이미 개발된 클래스 사용 시 중요한 것은 `클래스의 경계를 구분 짓는 것`
    - 어떤 부분을 외부에 공개할지, 내부로 감출지 결정하는 것이 핵심
    → **경계의 명확성이 객체의 자율성을 보장하기 때문 ! +) 프로그래머에게 구현의 자유 제공**

### 자율적인 객체

- 객체는 상태, 행동을 함께 가지며, 스스로 판단하고 행동하는 자율적인 존재이다
    - `캡슐화`: 데이터와 기능을 객체 내부로 함께 묶는 것
    - 대부분 객체지향 프로그래밍에서는 캡슐화에서 나아가, 외부에서 접근 통제가능한 `접근 제어` 메커니즘도 제공  
        → 객체 내부에 대한 접근을 통제하는 이유 : **객체를** 경계의 명확성을 보장하는 **자율적인 존재로 만들기 위해서**
        - 객체를 자율적인 존재로 만들기 위해서는 외부 간섭을 최소화 해야 함
    - `퍼블릭 인터페이스`  : 외부에서 접근 가능한 부분 (public 메소드)
    - `구현` : 외부에서 접근 불가능 / 내부에서만 접근 가능 (private, protected 메소드, 속성)
        → 일반적으로 객체의 상태는 숨기고, 행동만 외부에 공개해야 함
        

### 프로그래머의 자유

- `클래스 작성자` 는 새로운 데이터 타입을 프로그램에 추가하는 사람
- `클라이언트 프로그래머` 는 클래스 작성자가 추가한 데이터 타입을 사용하는 사람
- 클래스 작성자는, 클라이언트 프로그래머가 숨겨 놓은 부분에 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 내부 구현 마음대로 변경 가능 → `구현 은닉`
- `접근제어` : 클래스 **내부, 외부를 명확하게 경계** 지을 수 있게 함 + 클래스 작성자가 **내부 구현을 은닉**할 수 있게 함
    - 클래스 작성자는 자유롭게 구현부 변경 가능
    - 클라이언트 프로그래머는 내부 구현 무시한 채 인터페이스만으로도 클래스 사용 가능

### 객체 간의 협력

- 객체끼리 상호작용할 수 있는 유일한 방법은 `메시지 전송/수신`
- 메시지 수신 객체는 **스스로의 결정에 따라** 자율적으로 메시지 처리 방법 결정
    - 수신된 메시지를 처리하기 위한 자신만의 방법을 **메소드** 라고 함
    → 메시지와 메소드를 구분해야 함. (다형성 개념의 시작)
    > Screening 클래스에 movie.calculate() 이 있으면, Screening 이 **Movie 의 calculate 메소드를 호출한다**, 라고 말했지만<br>
    사실은 Screening 이 **Movie 에게 calculate 메시지를 전송한다**. 가 적절한 표현<br>
    → 왜냐하면 Screening 은 Movie 안에 calculate 메소드의 존재 여부를 알지못하고, 단지 Movie 가 calculate 메시지에 응답할 수 있다고 믿고 메시지를 전송하는 것이기 때문<br>
    → 메시지를 수신한 Movie 는 스스로 적절한 메소드를 선택함 (즉, 메시지 처리 방법 결정은 Movie - 메시지 수신 객체의 몫인 것)
    >

### 할인 요금 구하기 예제 _ 상속, 다형성, 추상화

```java
public class Movie {
	private Money fee;
	private DiscountPolicy discountPolicy;

	public Money calculateMovieFee(Screening screening){
		return fee.minus(discountPolicy.calculateDiscountAmount(screening);
	}
}
```

- 영화에 적용되어 있는 할인 정책의 종류를 판단하는 코드는 존재하지 않고, 다만 discountPolicy 에게 calculateDiscountAmount 라는 메시지를 전송할 뿐이다
== `할인정책` 에게 `금액할인을 계산해줘` 라는 메시지 전송

```java
public abstract class DiscountPolicy {
	List<DiscountCondition> conditions = new ArrayList<>(); // 할인 조건 리스트

	public Money calculateDiscountAmount(Screening screening){
		for(DiscountCondition each: conditions){
			if(each.isSatisfiedBy(screening){
				return getDiscountAmount(screening);
			}
		}
	}
	abstract protected Money getDiscountAmount(Screening screening);
}
```

- DiscountPolicy 가 전체적인 흐름은 저의하지만, 실제로 요금 계산하는부분은 추상메소드인 **getDiscountAmount 메소드에게 위임 == DiscountPolicy 를 상속받은 자식 클래스에서 오버라이딩한 메소드 실행**
    - 템플릿 메소드 패턴 : 부모 클래스에 기본적인 흐름 구현하고, 중간에 필요한 처리를 자식에게 위임하는 디자인 패턴
- 각 할인정책마다도, 할인액을 산정하는 기준 (금액, 비율) 이 다르기 때문에 인터페이스를 구현해서 추상메소드를 오버라이딩하여 구현

```java
public interface DiscountCondition {
	boolean isSatisfiedBy(Screening screening);
}
```

- 각 할인조건마다 만족여부를 따지는 코드가 다르므로 인터페이스를 구현해서 자식 클래스에서 메소드를 오버라이딩함

### 상속과 다형성

- 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지는 경우
- 해당 클래스의 객체의 메소드를 호출할 경우

→ 두 클래스 사이에 `의존성이 존재한다`

- Movie 인스턴스는 실행시에 amount / percent DiscountPolicy 인스턴스에 의존해야 하지만 현재는 오로지 추상 클래스인 DiscountPolicy에만 의존하고 있다

<br>



## 이 장에서 얻은 것
- 변경된 가능성이 있는 세부 구현을 private 영역 안에 감춤으로써 변경 관리를 손쉽게 할 수 있다.
